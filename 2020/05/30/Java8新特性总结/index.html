<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java8新特性总结 | 凌虚阁</title><meta name="description" content="万众期待的 Java™EE 8 即将发布。这是自 2013 年 6 月以来 Java 企业平台的首次发布，是分成两部分的发布中的前半部分（后一部分是 Java EE 9）。Oracle 对 Java EE 进行了战略性重新定位，重点关注一些支持云计算、微服务和反应式编程的技术。反应式编程现在正融入到许多 Java EE API 的架构中，而 JSON 交换格式为核心平台提供了支撑。 我们将大体了解"><meta name="keywords" content="Java"><meta name="author" content="GuoTao"><meta name="copyright" content="GuoTao"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://tomones.github.io/2020/05/30/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="Java8新特性总结"><meta property="og:url" content="https://tomones.github.io/2020/05/30/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/"><meta property="og:site_name" content="凌虚阁"><meta property="og:description" content="万众期待的 Java™EE 8 即将发布。这是自 2013 年 6 月以来 Java 企业平台的首次发布，是分成两部分的发布中的前半部分（后一部分是 Java EE 9）。Oracle 对 Java EE 进行了战略性重新定位，重点关注一些支持云计算、微服务和反应式编程的技术。反应式编程现在正融入到许多 Java EE API 的架构中，而 JSON 交换格式为核心平台提供了支撑。 我们将大体了解"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2020-05-30T15:18:23.000Z"><meta property="article:modified_time" content="2020-07-20T15:36:42.559Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="next" title="Linux常用命令" href="https://tomones.github.io/2020/05/30/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="凌虚阁" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="http://cdn.andiycc.com/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">7</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">5</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><span> 娱乐</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#全新的-API-和更新的-API"><span class="toc-number">1.</span> <span class="toc-text">全新的 API 和更新的 API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JSON-Binding-API"><span class="toc-number">2.</span> <span class="toc-text">JSON Binding API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#规范内容"><span class="toc-number">2.1.</span> <span class="toc-text">规范内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用-JsonB-实现序列化和反序列化"><span class="toc-number">2.2.</span> <span class="toc-text">使用 JsonB 实现序列化和反序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#清单-1-序列化和反序列化的最简单示例"><span class="toc-number">2.2.0.1.</span> <span class="toc-text">清单 1. 序列化和反序列化的最简单示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义-Jsonb"><span class="toc-number">2.3.</span> <span class="toc-text">自定义 Jsonb</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#清单-2-自定义-Jsonb"><span class="toc-number">2.3.0.1.</span> <span class="toc-text">清单 2. 自定义 Jsonb</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#清单-3-自定义的-JSON-结构"><span class="toc-number">2.3.0.2.</span> <span class="toc-text">清单 3. 自定义的 JSON 结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#清单-4-Jsonb-的运行时配置"><span class="toc-number">2.3.0.3.</span> <span class="toc-text">清单 4. Jsonb 的运行时配置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#开源绑定"><span class="toc-number">2.4.</span> <span class="toc-text">开源绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#清单-5-开源绑定配置"><span class="toc-number">2.4.0.1.</span> <span class="toc-text">清单 5. 开源绑定配置</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-EE-Security-API"><span class="toc-number">3.</span> <span class="toc-text">Java EE Security API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#规范内容-1"><span class="toc-number">3.1.</span> <span class="toc-text">规范内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HttpAuthenticationMechanism"><span class="toc-number">3.2.</span> <span class="toc-text">HttpAuthenticationMechanism</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IdentityStore"><span class="toc-number">3.3.</span> <span class="toc-text">IdentityStore</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SecurityContext"><span class="toc-number">3.4.</span> <span class="toc-text">SecurityContext</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#主要更新：Servlet-4-0、Bean-Validation-2-0、CDI-2-0"><span class="toc-number">4.</span> <span class="toc-text">主要更新：Servlet 4.0、Bean Validation 2.0、CDI 2.0</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Servlet-4-0"><span class="toc-number">4.1.</span> <span class="toc-text">Servlet 4.0</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PushBuilder"><span class="toc-number">4.1.1.</span> <span class="toc-text">PushBuilder</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#清单-6-servlet-中的-PushBuilder"><span class="toc-number">4.1.1.1.</span> <span class="toc-text">清单 6. servlet 中的 PushBuilder</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#servlet-映射的运行时发现"><span class="toc-number">4.1.2.</span> <span class="toc-text">servlet 映射的运行时发现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#清单-7-HttpServletMapping-接口上的所有-4-个方法"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">清单 7. HttpServletMapping 接口上的所有 4 个方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean-Validation-2-0"><span class="toc-number">4.2.</span> <span class="toc-text">Bean Validation 2.0</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#清单-8-按类型验证容器元素"><span class="toc-number">4.2.0.1.</span> <span class="toc-text">清单 8. 按类型验证容器元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#清单-9-Bean-Validation-2-0-支持-Date-和-Time-类型，以及-Optional"><span class="toc-number">4.2.0.2.</span> <span class="toc-text">清单 9. Bean Validation 2.0 支持 Date 和 Time 类型，以及 Optional</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#清单-10-容器类型的级联验证"><span class="toc-number">4.2.0.3.</span> <span class="toc-text">清单 10. 容器类型的级联验证</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Contexts-and-Dependency-Injection-for-Java-2-0"><span class="toc-number">4.3.</span> <span class="toc-text">Contexts and Dependency Injection for Java 2.0</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CDI-2-0-中的观察者和事件"><span class="toc-number">4.3.1.</span> <span class="toc-text">CDI 2.0 中的观察者和事件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#清单-11-观察者优先级演示"><span class="toc-number">4.3.1.1.</span> <span class="toc-text">清单 11. 观察者优先级演示</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#异步事件"><span class="toc-number">4.3.2.</span> <span class="toc-text">异步事件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#清单-12-异步触发事件"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">清单 12. 异步触发事件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#清单-13-管理异步观察者中的异常"><span class="toc-number">4.3.2.2.</span> <span class="toc-text">清单 13. 管理异步观察者中的异常</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#次要更新：JAX-RS-2-1、JSF-2-3、JSON-P-1-1"><span class="toc-number">5.</span> <span class="toc-text">次要更新：JAX-RS 2.1、JSF 2.3、JSON-P 1.1</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-API-for-RESTful-Web-Services-2-1"><span class="toc-number">5.1.</span> <span class="toc-text">Java API for RESTful Web Services 2.1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#反应式客户端-API"><span class="toc-number">5.1.1.</span> <span class="toc-text">反应式客户端 API</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#清单-14-包含新-rx-方法的调用构建器"><span class="toc-number">5.1.1.1.</span> <span class="toc-text">清单 14. 包含新 rx() 方法的调用构建器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#清单-15-调用不同端点后的组合结果"><span class="toc-number">5.1.1.2.</span> <span class="toc-text">清单 15. 调用不同端点后的组合结果</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#服务器发送的事件"><span class="toc-number">5.1.2.</span> <span class="toc-text">服务器发送的事件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#清单-16-针对服务器发送的事件的-JAX-RS-客户端-API"><span class="toc-number">5.1.2.1.</span> <span class="toc-text">清单 16. 针对服务器发送的事件的 JAX-RS 客户端 API</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#清单-17-用于服务器发送的事件的服务器-API"><span class="toc-number">5.1.2.2.</span> <span class="toc-text">清单 17. 用于服务器发送的事件的服务器 API</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#广播服务器发送的事件"><span class="toc-number">5.1.3.</span> <span class="toc-text">广播服务器发送的事件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#清单-18-广播到所有已注册的订阅者"><span class="toc-number">5.1.3.1.</span> <span class="toc-text">清单 18. 广播到所有已注册的订阅者</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对-JAX-RS-2-1-的其他更新"><span class="toc-number">5.1.4.</span> <span class="toc-text">对 JAX-RS 2.1 的其他更新</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaServer-Faces-2-3"><span class="toc-number">5.2.</span> <span class="toc-text">JavaServer Faces 2.3</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JSF-2-3-中的服务器推送"><span class="toc-number">5.2.1.</span> <span class="toc-text">JSF 2.3 中的服务器推送</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSON-Processing-1-1"><span class="toc-number">5.3.</span> <span class="toc-text">JSON Processing 1.1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JSON-Pointer"><span class="toc-number">5.3.1.</span> <span class="toc-text">JSON-Pointer</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#清单-19-一个包含数组的-JSON-对象"><span class="toc-number">5.3.1.1.</span> <span class="toc-text">清单 19. 一个包含数组的 JSON 对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#清单-20-JsonPointer-引用一个数组元素"><span class="toc-number">5.3.1.2.</span> <span class="toc-text">清单 20. JsonPointer 引用一个数组元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#清单-21-使用-JsonPointer-向数组添加值"><span class="toc-number">5.3.1.3.</span> <span class="toc-text">清单 21. 使用 JsonPointer 向数组添加值</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JSON-Patch"><span class="toc-number">5.3.2.</span> <span class="toc-text">JSON Patch</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#清单-22-替换了数组中的值的-JsonPatchBuilder"><span class="toc-number">5.3.2.1.</span> <span class="toc-text">清单 22. 替换了数组中的值的 JsonPatchBuilder</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JSON-Merge-Patch"><span class="toc-number">5.3.3.</span> <span class="toc-text">JSON Merge Patch</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#表-1-选择合并修订操作"><span class="toc-number">5.3.3.1.</span> <span class="toc-text">表 1. 选择合并修订操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#清单-23-使用-JSON-Merge-Patch-来替换值"><span class="toc-number">5.3.3.2.</span> <span class="toc-text">清单 23. 使用 JSON Merge Patch 来替换值</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JsonCollectors"><span class="toc-number">5.3.4.</span> <span class="toc-text">JsonCollectors</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#清单-24-使用-JsonCollectors-过滤数组并将结果收集到-JsonArray-中"><span class="toc-number">5.3.4.1.</span> <span class="toc-text">清单 24. 使用 JsonCollectors 过滤数组并将结果收集到 JsonArray 中</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结束语"><span class="toc-number">6.</span> <span class="toc-text">结束语</span></a></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">凌虚阁</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><span> 娱乐</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Java8新特性总结</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-05-30 23:18:23"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2020-05-30</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-07-20 23:36:42"><i class="fas fa-history fa-fw"></i> 更新于 2020-07-20</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta__icon"></i><span>字数总计:</span><span class="word-count">6.4k</span><span class="post-meta__separator">|</span><i class="far fa-clock fa-fw post-meta__icon"></i><span>阅读时长: 23 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>万众期待的 Java™EE 8 即将发布。这是自 2013 年 6 月以来 Java 企业平台的首次发布，是分成两部分的发布中的前半部分（后一部分是 Java EE 9）。Oracle 对 Java EE 进行了战略性重新定位，重点关注一些支持云计算、微服务和反应式编程的技术。反应式编程现在正融入到许多 Java EE API 的架构中，而 JSON 交换格式为核心平台提供了支撑。 我们将大体了解 Java EE 8 中提供的主要特性。重点包括 API 更新和引入、对 HTTP/2 的新支持、反应式编程，以及 JSON。我们首先会介绍 Java EE 规范和升级，它们无疑将决定企业 Java 编程未来几年的发展方向。</p>
<h2 id="全新的-API-和更新的-API"><a href="#全新的-API-和更新的-API" class="headerlink" title="全新的 API 和更新的 API"></a>全新的 API 和更新的 API</h2><p>Java EE 8 向核心 API 引入了一些主要和次要更新，比如 Servlet 4.0 和 Context and Dependency Injection 2.0。还引入了两个新的 API —Java API for JSON Binding (<a href="https://www.jcp.org/en/jsr/detail?id=367" target="_blank" rel="noopener">JSR 367</a>) 和 Java EE Security API (<a href="https://www.jcp.org/en/jsr/detail?id=375" target="_blank" rel="noopener">JSR 375</a>)。我们首先介绍新的 API，然后探索对存在已久的 Java EE 规范的改动。</p>
<h2 id="JSON-Binding-API"><a href="#JSON-Binding-API" class="headerlink" title="JSON Binding API"></a>JSON Binding API</h2><p>新的 JSON Binding API (JSON-B) 支持在 Java 对象与<a href="https://tools.ietf.org/html/rfc7159" target="_blank" rel="noopener">兼容 RFC 7159 的</a> JSON 之间执行序列化和反序列化，同时维护与 JAXB (<a href="https://jcp.org/en/jsr/detail?id=222" target="_blank" rel="noopener">Java API for XML Binding 2.0</a>) 的一致性。它提供了从 Java 类和实例到符合公认约定的 JSON 文档的默认映射。 JSON-B xu 还允许开发人员自定义序列化和反序列化。您可以使用注释自定义各个类的这些流程，或者使用运行时配置构建器来开发自定义策略。后一种方法包括使用适配器来支持用户定义的自定义。JSON-B 与 Java API for JSON Processing (JSON-P) 1.1（本文后面将讨论）紧密集成。</p>
<h3 id="规范内容"><a href="#规范内容" class="headerlink" title="规范内容"></a>规范内容</h3><p>两个接口为新的 JSON Binding API 提供了入口： JsonbBinding  和  Jsonb 。</p>
<ul>
<li>JsonbBinding  提供了 JSON Binding API 的客户端访问点。为此，它通过根据所设置的配置和参数来构建  Jsonb  实例。</li>
<li>Jsonb  通过方法  toJson()  和  fromJson()  提供序列化和反序列化操作。</li>
</ul>
<p>JSON-B 还可以向插入的外部 JSON Binding 提供者描述功能，所以您不受 API 附带的绑定逻辑的限制。</p>
<h3 id="使用-JsonB-实现序列化和反序列化"><a href="#使用-JsonB-实现序列化和反序列化" class="headerlink" title="使用 JsonB 实现序列化和反序列化"></a>使用 JsonB 实现序列化和反序列化</h3><p>清单 1 首先序列化  Book  类  book  的实例，然后将其反序列化。</p>
<h5 id="清单-1-序列化和反序列化的最简单示例"><a href="#清单-1-序列化和反序列化的最简单示例" class="headerlink" title="清单 1. 序列化和反序列化的最简单示例"></a>清单 1. 序列化和反序列化的最简单示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String bookJson = JsonbBuilder.create().toJson(book);</span><br><span class="line">Book book = JsonbBuilder.create().fromJson(bookJson, Book<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>静态  create()  工厂方法返回一个  Jsonb  实例。您可以在该实例上调用许多重载的  toJson()  和  fromJson()  方法。另请注意，该规范没有强制要求来回等效转换：在上面的示例中，将  bookJson  字符串传入  fromJson()  方法中可能不会反序列化为一个等效对象。 JSON-B 还支持采用与对象大致相同的方式来绑定集合类与原语和/或实例数组 —包括多维数组。</p>
<h3 id="自定义-Jsonb"><a href="#自定义-Jsonb" class="headerlink" title="自定义 Jsonb"></a>自定义 Jsonb</h3><p>可通过为字段、JavaBeans 方法和类添加注释，对  Jsonb  方法的默认行为进行自定义。 例如，可以使用  @JsonbNillable  和  @JsonbPropertyOrder  注释来自定义 null 处理和属性顺序，该顺序应在类级别上进行自定义：</p>
<h5 id="清单-2-自定义-Jsonb"><a href="#清单-2-自定义-Jsonb" class="headerlink" title="清单 2. 自定义 Jsonb"></a>清单 2. 自定义 Jsonb</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonbNillable</span></span><br><span class="line"><span class="meta">@JsonbPropertyOrder</span>(PropertyOrderStrategy.REVERSE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Booklet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="meta">@JsonbProperty</span>(<span class="string">"cost"</span>)</span><br><span class="line">    <span class="meta">@JsonbNumberFormat</span>(<span class="string">"#0.00"</span>)</span><br><span class="line">    <span class="keyword">private</span> Float price;</span><br><span class="line">    <span class="keyword">private</span> Author author;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@JsonbTransient</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@JsonbTransient</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">    		<span class="keyword">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// price and author getters/setter removed for brevity</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用方法  toJson()  会生成清单 3 中所示的 JSON 结构。</p>
<h5 id="清单-3-自定义的-JSON-结构"><a href="#清单-3-自定义的-JSON-结构" class="headerlink" title="清单 3. 自定义的 JSON 结构"></a>清单 3. 自定义的 JSON 结构</h5><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"cost"</span>: <span class="string">"10.00"</span>,</span><br><span class="line">    <span class="attr">"author"</span>: &#123;</span><br><span class="line">        <span class="attr">"firstName"</span>: <span class="string">"Alex"</span>,</span><br><span class="line">        <span class="attr">"lastName"</span>: <span class="string">"Theedom"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以选择通过运行时配置构建器  JsonbConfig  来执行自定义：</p>
<h5 id="清单-4-Jsonb-的运行时配置"><a href="#清单-4-Jsonb-的运行时配置" class="headerlink" title="清单 4. Jsonb 的运行时配置"></a>清单 4. Jsonb 的运行时配置</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JsonbConfig jsonbConfig = <span class="keyword">new</span> JsonbConfig()        </span><br><span class="line">  .withPropertyNamingStrategy(   </span><br><span class="line">  PropertyNamingStrategy.LOWER_CASE_WITH_DASHES)  </span><br><span class="line">  .withNullValues(<span class="keyword">true</span>)  </span><br><span class="line">  .withFormatting(<span class="keyword">true</span>);   </span><br><span class="line">Jsonb jsonb = JsonbBuilder.create(jsonbConfig);</span><br></pre></td></tr></table></figure>

<p>清单 4 将 JSON-B 配置为使用  LOWER_CASE_WITH_DASHES  约定，以便将 null 保留在它们所在的位置，并输出经过优化的 JSON。</p>
<h3 id="开源绑定"><a href="#开源绑定" class="headerlink" title="开源绑定"></a>开源绑定</h3><p>前面已经提到过，您不需要使用现成的 JSON-B 选项。清单 5 展示了如何配置开源绑定实现：</p>
<h5 id="清单-5-开源绑定配置"><a href="#清单-5-开源绑定配置" class="headerlink" title="清单 5. 开源绑定配置"></a>清单 5. 开源绑定配置</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JsonbBuilde r builder = JsonbBuilder.newBuilder(<span class="string">"aProvider"</span>);</span><br></pre></td></tr></table></figure>

<h2 id="Java-EE-Security-API"><a href="#Java-EE-Security-API" class="headerlink" title="Java EE Security API"></a>Java EE Security API</h2><p>新 Java EE Security API 的引入，是为了更正各种 servlet 容器在解决安全问题的方式上的不一致。这个问题在 Java Web 配置文件中尤为突出，主要是因为 Java EE 仅规定了完整的 Java EE 配置文件必须如何实现标准 API。新规范还引入了一些现有 API 没有利用的现代功能，比如 CDI。 这个 API 的美妙之处在于，它提供了一种配置身份存储和身份验证机制的备选方法，但没有取代现有安全机制。开发人员应该非常希望拥有在 Java EE Web 应用程序中启用安全性的机会，无论是否使用特定于供应商的解决方案或专用的解决方案。</p>
<h3 id="规范内容-1"><a href="#规范内容-1" class="headerlink" title="规范内容"></a>规范内容</h3><p>Java EE Security API 规范解决了 3 个关键问题：</p>
<ul>
<li>HttpAuthenticationMechanism  支持对 servlet 容器执行身份验证。</li>
<li>IdentityStore  标准化了 JAAS  LoginModule 。</li>
<li>SecurityContext  提供了一个实现编程安全的访问点。</li>
</ul>
<p>下面将介绍上述每个组件。</p>
<h3 id="HttpAuthenticationMechanism"><a href="#HttpAuthenticationMechanism" class="headerlink" title="HttpAuthenticationMechanism"></a>HttpAuthenticationMechanism</h3><p>Java EE 已指定了两种验证 Web 应用程序用户的机制：Java Servlet 规范 3.1 (JSR-340) 指定了一种声明性的应用程序配置机制，而 JASPIC (Java Authentication Service Provider Interface for Containers) 定义了一个名为  ServerAuthModule  的 SPI，该 SPI 支持开发身份验证模块来处理任何凭证类型。 这两种机制既有意义又很有效，但从 Web 应用程序开发人员的角度讲，每种机制都存在局限性。servlet 容器机制仅支持小范围的凭证类型。JASPIC 非常强大和灵活，但使用起来也非常复杂。 Java EE Security API 希望通过一个新接口解决这些问题： HttpAuthenticationMechanism 。这个新接口实际上是 JASPIC ServerAuthModule  接口的一个简化的 servlet 容器变体，它在减少现有机制的局限性的同时利用现有机制。  HttpAuthenticationMechanism  类型的实例是一个 CDI bean，可将它用于实现注入操作的容器，而且该实例被指定仅用于 servlet 容器。该规范明确排除了 EJB 和 JMS 等其他容器。  HttpAuthenticationMechanism  接口定义了 3 个方法： validateRequest() 、 secureResponse()  和  cleanSubject() 。这些方法非常类似于 JASPIC  ServerAuth  接口上声明的方法，所以开发人员应该对它们感到熟悉。唯一需要重写的方法是 validateRequest() ；其他所有方法都有默认实现。</p>
<h3 id="IdentityStore"><a href="#IdentityStore" class="headerlink" title="IdentityStore"></a>IdentityStore</h3><p><em>身份存储</em>是一个数据库，用于存储用户身份数据，比如用户名、组成员关系，以及用于验证凭证的信息。在新的 Java EE Security API 中，使用了一个名为  IdentityStore  的身份存储抽象来与身份存储进行交互。它的用途是验证用户并检索组成员信息。 正如规范中所写， IdentityStore  的意图是供  HttpAuthenticationMechanism  实现使用，不过这不是必须的。结合使用 IdentityStore  和  HttpAuthenticationMechanism ，使得应用程序能以一种便携的、标准的方式控制其身份存储。</p>
<h3 id="SecurityContext"><a href="#SecurityContext" class="headerlink" title="SecurityContext"></a>SecurityContext</h3><p> IdentityStore  和  HttpAuthenticationMechanism  相结合，成为了一个强大的新的用户身份验证工具。然而，声明性模型可能无法满足系统级安全需求。 SecurityContext  可在这里派上用场：编程安全使得 Web 应用程序能执行所需的测试，从而允许或拒绝访问应用程序资源。</p>
<h2 id="主要更新：Servlet-4-0、Bean-Validation-2-0、CDI-2-0"><a href="#主要更新：Servlet-4-0、Bean-Validation-2-0、CDI-2-0" class="headerlink" title="主要更新：Servlet 4.0、Bean Validation 2.0、CDI 2.0"></a>主要更新：Servlet 4.0、Bean Validation 2.0、CDI 2.0</h2><p>Java EE 8 中主要提供了 3 个企业标准 API：Servlet 4.0 (<a href="https://jcp.org/en/jsr/detail?id=369" target="_blank" rel="noopener">JSR 369</a>)、Bean Validation 2.0 (<a href="https://jcp.org/en/jsr/detail?id=380" target="_blank" rel="noopener">JSR 380</a>) 和 Contexts and Dependency Injection for Java 2.0 (<a href="https://jcp.org/en/jsr/detail?id=365" target="_blank" rel="noopener">JSR 365</a>)。 下面将介绍每个 API 的重要特性。</p>
<h3 id="Servlet-4-0"><a href="#Servlet-4-0" class="headerlink" title="Servlet 4.0"></a>Servlet 4.0</h3><p>Java Servlet API 是 Java 企业开发人员最早接触、最熟悉的 API 之一。它于 1999 年在 J2EE 1.2 中首次面世，现在在 Java Server Pages (JSP)、JavaServer Faces (JSF)、JAX-RS 和 MVC (<a href="https://jcp.org/en/jsr/detail?id=371" target="_blank" rel="noopener">JSR 371</a>) 中发挥着重要作用。 Java EE 8 中对 Servlet 进行了重大修订，主要是为了适应 [HTTP/2](<a href="https://www.ibm.com/developerworks/library/wa-http2-under-the-hood" target="_blank" rel="noopener">https://www.ibm.com/developerworks/library/wa-http2-under-the-hood</a> /index.html) 的性能增强特性。服务器推送目前是这一领域的首要特性。 <strong>服务器推送是什么？</strong> <em>服务器推送</em>通过将客户端资源推送到浏览器的缓存中来预先满足对这些资源的需求。客户端发送请求并收到服务器响应时，所需的资源已在缓存中。</p>
<h4 id="PushBuilder"><a href="#PushBuilder" class="headerlink" title="PushBuilder"></a>PushBuilder</h4><p>在 Servlet 4.0 中，服务器推送是通过一个  PushBuilder  实例公开的。清单 6 展示了一个从 HttpServletResponse  实例获取的  PushBuilder  实例，该实例被传递到一个请求处理方法。</p>
<h5 id="清单-6-servlet-中的-PushBuilder"><a href="#清单-6-servlet-中的-PushBuilder" class="headerlink" title="清单 6. servlet 中的 PushBuilder"></a>清单 6. servlet 中的 PushBuilder</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request,            </span></span></span><br><span class="line"><span class="function"><span class="params">                     HttpServletResponse response)</span>            </span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> ServletException, IOException </span>&#123;   </span><br><span class="line">  PushBuilder pushBuilder = request.newPushBuilder(); </span><br><span class="line">  pushBuilder.path(<span class="string">"images/header.png"</span>).push();  </span><br><span class="line">  pushBuilder.path(<span class="string">"css/menu.css"</span>).push(); </span><br><span class="line">  pushBuilder.path(<span class="string">"js/ajax.js"</span>).push(); </span><br><span class="line">  <span class="comment">// Do some processing and return JSP that   </span></span><br><span class="line">  <span class="comment">// requires these resources  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在清单 6 中， header.png  的路径是通过  path()  方法在  PushBuilder  实例上设置的，并通过调用  push()  推送到客户端。该方法返回时，会清除路径和条件标头，以供构建器重用。</p>
<h4 id="servlet-映射的运行时发现"><a href="#servlet-映射的运行时发现" class="headerlink" title="servlet 映射的运行时发现"></a>servlet 映射的运行时发现</h4><p>Servlet 4.0 提供了一个新的 API，用它来实现 URL 映射的运行时发现。 HttpServletMapping  接口的用途是让确定导致 servlet 激活的映射变得更容易。在该 API 内，会从一个  HttpServletRequest  实例获得 servlet 映射，该实例包含 4 个方法：</p>
<ul>
<li>getMappingMatch()  返回匹配的类型。</li>
<li>getPattern()  返回激活 servlet 请求的 URL 模式。</li>
<li>getMatchValue()  返回匹配的  String </li>
<li>getServletName()  返回通过该请求激活的 servlet 类的完全限定名称。</li>
</ul>
<h5 id="清单-7-HttpServletMapping-接口上的所有-4-个方法"><a href="#清单-7-HttpServletMapping-接口上的所有-4-个方法" class="headerlink" title="清单 7. HttpServletMapping 接口上的所有 4 个方法"></a>清单 7. HttpServletMapping 接口上的所有 4 个方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HttpServletMapping mapping = request.getHttpServletMapping();  </span><br><span class="line">String mapping = mapping.getMappingMatch().name();  </span><br><span class="line">String value = mapping.getMatchValue();  </span><br><span class="line">String pattern = mapping.getPattern();  </span><br><span class="line">String servletName = mapping.getServletName();</span><br></pre></td></tr></table></figure>

<p>除了这些更新之外，Servlet 4.0 还包含更细微的管理性更改和对 <a href="https://tools.ietf.org/html/rfc7230" target="_blank" rel="noopener">HTTP Trailer</a> 的支持。新的  GenericFilter  和  HttpFilter  类简化了过滤器的编写，实现了对 Java SE 8 的一般性改进。</p>
<h3 id="Bean-Validation-2-0"><a href="#Bean-Validation-2-0" class="headerlink" title="Bean Validation 2.0"></a>Bean Validation 2.0</h3><p>Bean Validation 2.0 通过一系列新特性得到了增强，其中许多特性是 Java 开发人员社区所请求的。Bean 验证是一个横切关注点，所以 2.0 版规范希望确保数据在从客户端传输到数据库的过程中是完整的，并通过对字段值、返回值和方法参数应用约束来实现此目的。 这些增强中包含一些约束，它们可以验证电子邮箱地址，确保数字是正的或负的，测试日期是过去还是现在，并测试字段不是空的或 null。这些约束包括： @Email 、 @Positive 、 @PositiveOrZero 、 @Negative 、 @NegativeOrZero 、 @PastOrPresent 、 @FutureOrPresent 、 @NotEmpty  和  @NotBlank 。这些约束现在也可应用于更广泛的地方。例如，它们可以继续处理参数化类型的参数。添加了对按类型参数来验证容器元素的支持，如清单 8 所示。</p>
<h5 id="清单-8-按类型验证容器元素"><a href="#清单-8-按类型验证容器元素" class="headerlink" title="清单 8. 按类型验证容器元素"></a>清单 8. 按类型验证容器元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;<span class="meta">@Size</span>(min = <span class="number">30</span>) String&gt; chapterTitles;</span><br></pre></td></tr></table></figure>

<p>更新后的 Bean Validation API 改进了 Java SE 8 的  Date  和  Time  类型，提供了对  java.util.Optional  的支持，如清单 9 所示。</p>
<h5 id="清单-9-Bean-Validation-2-0-支持-Date-和-Time-类型，以及-Optional"><a href="#清单-9-Bean-Validation-2-0-支持-Date-和-Time-类型，以及-Optional" class="headerlink" title="清单 9. Bean Validation 2.0 支持 Date 和 Time 类型，以及 Optional"></a>清单 9. Bean Validation 2.0 支持 Date 和 Time 类型，以及 Optional</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;<span class="meta">@Size</span>(min = <span class="number">10</span>) String&gt; title;  </span><br><span class="line"><span class="keyword">private</span> <span class="meta">@PastOrPresent</span> Year released;  </span><br><span class="line"><span class="keyword">private</span> <span class="meta">@FutureOrPresent</span> LocalDate nextVersionRelease;  </span><br><span class="line"><span class="keyword">private</span> <span class="meta">@Past</span> LocalDate publishedDate;</span><br></pre></td></tr></table></figure>

<p>容器的级联验证是一个很方便的新特性。使用  @Valid  对容器的任何类型参数进行注释，都会导致在验证父对象时验证每个元素。在清单 10 中，将会验证每个  String  和  Book  元素，如下所示：</p>
<h5 id="清单-10-容器类型的级联验证"><a href="#清单-10-容器类型的级联验证" class="headerlink" title="清单 10. 容器类型的级联验证"></a>清单 10. 容器类型的级联验证</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;<span class="meta">@Valid</span> String, <span class="meta">@Valid</span> Book&gt; otherBooksByAuthor;</span><br></pre></td></tr></table></figure>

<p>Bean Validation 还通过插入值提取器来添加对自定义容器类型的支持。内置的约束被标记为 repeatable，参数名是通过反射来检索的， ConstraintValidator#initialize()  是默认方法。JavaFX 还获得了对其类型的支持。</p>
<h3 id="Contexts-and-Dependency-Injection-for-Java-2-0"><a href="#Contexts-and-Dependency-Injection-for-Java-2-0" class="headerlink" title="Contexts and Dependency Injection for Java 2.0"></a>Contexts and Dependency Injection for Java 2.0</h3><p>Context and Dependency Injection API (CDI) 是一种自第 6 版开始就存在于 Java EE 中的主干技术。从那时起，它就成为了一个简化开发的关键特性。 在最新版本中，该 API 已扩展用于 Java SE。为了适应这一更改，CDI 规范被分解为 3 部分：第 1 部分处理 Java EE 和 Java SE 中的通用概念；第 2 部分处理仅针对 CDI with Java SE 的规则；第 3 部分处理仅针对 Java EE 的规则。 CDI 2.0 还对观察者和事件的行为及交互方式进行了重大更改。</p>
<h4 id="CDI-2-0-中的观察者和事件"><a href="#CDI-2-0-中的观察者和事件" class="headerlink" title="CDI 2.0 中的观察者和事件"></a>CDI 2.0 中的观察者和事件</h4><p>在 CDI 1.1 中，在触发事件时会同步调用观察者，没有任何机制来定义执行它们的顺序。此行为的问题在于，如果某个观察者抛出异常，则不会再调用所有后续观察者，观察者链将会中断。在 CDI 2.0 中，通过引入  @Priority  注释，从某种程度上减轻了这一问题，该注释指定了调用观察者应该采用的顺序，编号越小的观察者越先调用。 清单 11 展示了一次事件触发和两个具有不同优先级的观察者。观察者  AuditEventReciever1 （优先级为 10）在  AuditEventReciever2 （优先级为 100）前调用。</p>
<h5 id="清单-11-观察者优先级演示"><a href="#清单-11-观察者优先级演示" class="headerlink" title="清单 11. 观察者优先级演示"></a>清单 11. 观察者优先级演示</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inject</span>  </span><br><span class="line"><span class="keyword">private</span> Event&lt;AuditEvent&gt; event;   </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(AuditEvent auditEvent)</span> </span>&#123;       </span><br><span class="line">  event.fire(auditEvent);  &#125;   </span><br><span class="line"><span class="comment">// AuditEventReciever1.class  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(@Observes @Priority(<span class="number">10</span>)</span> AuditEvent auditEvent) </span>&#123;        </span><br><span class="line">  <span class="comment">// react to event </span></span><br><span class="line">&#125;   </span><br><span class="line">  <span class="comment">// AuditEventReciever2.class   </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(@Observes @Priority(<span class="number">100</span>)</span> AuditEvent auditEvent) </span>&#123;  </span><br><span class="line">  <span class="comment">// react to event </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，具有相同优先级的观察者会按无法预测的顺序进行调用，默认顺序为 javax.interceptor.Interceptor.Priority.APPLICATION + 500 。</p>
<h4 id="异步事件"><a href="#异步事件" class="headerlink" title="异步事件"></a>异步事件</h4><p>对观察者特性添加的另一个有用功能是，异步触发事件。添加了一个新触发方法 ( Async() ) 和相应的观察者注释 ( @ObservesAsyncfire ) 来支持此特性。清单 12 展示了一个异步调用的  AuditEvent ，以及收到该事件的通知的观察者方法。</p>
<h5 id="清单-12-异步触发事件"><a href="#清单-12-异步触发事件" class="headerlink" title="清单 12. 异步触发事件"></a>清单 12. 异步触发事件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inject</span>  </span><br><span class="line"><span class="keyword">private</span> Event&lt;AuditEvent&gt; event;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletionStage&lt;AuditEvent&gt; <span class="title">sendAsync</span><span class="params">(AuditEvent auditEvent)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> event.fireAsync(auditEvent);  </span><br><span class="line">&#125;   </span><br><span class="line"><span class="comment">// AuditEventReciever1.class  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveAsync</span><span class="params">(@ObservesAsync AuditEvent auditEvent)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;   </span><br><span class="line"><span class="comment">// AuditEventReciever2.class  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveAsync</span><span class="params">(@ObservesAsync AuditEvent auditEvent)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果任何观察者抛出异常， CompletionStage  就会包含  CompletionException 。这个实例包含对在观察者调用期间抛出的所有受抑制异常的引用。清单 13 展示了如何管理此场景。</p>
<h5 id="清单-13-管理异步观察者中的异常"><a href="#清单-13-管理异步观察者中的异常" class="headerlink" title="清单 13. 管理异步观察者中的异常"></a>清单 13. 管理异步观察者中的异常</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletionStage&lt;AuditEvent&gt; <span class="title">sendAsync</span><span class="params">(AuditEvent auditEvent)</span> </span>&#123;  </span><br><span class="line">  System.out.println(<span class="string">"Sending async"</span>);       </span><br><span class="line">  CompletionStage&lt;AuditEvent&gt; stage = event.fireAsync(auditEvent)   </span><br><span class="line">    .handle((event, ex) -&gt; &#123;           </span><br><span class="line">      <span class="keyword">if</span> (event != <span class="keyword">null</span>) &#123;    </span><br><span class="line">        <span class="keyword">return</span> event;      </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;                 </span><br><span class="line">        <span class="keyword">for</span> (Throwable t : ex.getSuppressed()) &#123;&#125;   </span><br><span class="line">        <span class="keyword">return</span> auditEvent;                   </span><br><span class="line">      &#125;              </span><br><span class="line">    &#125;);        </span><br><span class="line">  <span class="keyword">return</span> stage; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面已经提到过，CDI 2.0 还对一些 Java SE 8 特性进行了一般性改进，比如流、lambda 表达式和可重复的修饰符。其他值得注意的增添内容包括：</p>
<ul>
<li>一个新的  Configurators  接口。</li>
<li>配置或否决观察者方法的能力。</li>
<li>内置的注释文字。</li>
<li>在  producer  上应用  interceptor  的能力。</li>
</ul>
<p><a href="https://issues.jboss.org/secure/ReleaseNote.jspa?version%3D12325406%26styleName%3D%26projectId%3D12311062%26_sscc%3Dt" target="_blank" rel="noopener">这里</a>提供了所有更改的完整列表。请参阅规范的<a href="https://docs.jboss.org/cdi/spec/2.0-PFD/cdi-spec-with-assertions.html" target="_blank" rel="noopener">建议最终草案</a>了解完整细节。</p>
<h2 id="次要更新：JAX-RS-2-1、JSF-2-3、JSON-P-1-1"><a href="#次要更新：JAX-RS-2-1、JSF-2-3、JSON-P-1-1" class="headerlink" title="次要更新：JAX-RS 2.1、JSF 2.3、JSON-P 1.1"></a>次要更新：JAX-RS 2.1、JSF 2.3、JSON-P 1.1</h2><p>尽管是相对次要的更新，但对 Java API for RESTful Web Services (<a href="https://jcp.org/en/jsr/detail?id=370" target="_blank" rel="noopener">JSR 370</a>)、JavaServer Faces 2.3 (<a href="https://jcp.org/en/jsr/detail?id=372" target="_blank" rel="noopener">JSR 372</a>) 和 Java API for JSON Processing 1.1 (<a href="https://jcp.org/en/jsr/detail?id=374" target="_blank" rel="noopener">JSR 374</a>) 的更改仍值得注意，尤其应该注意反应式和函数式编程的元素。</p>
<h3 id="Java-API-for-RESTful-Web-Services-2-1"><a href="#Java-API-for-RESTful-Web-Services-2-1" class="headerlink" title="Java API for RESTful Web Services 2.1"></a>Java API for RESTful Web Services 2.1</h3><p>JAX-RS 2.1 API 版本专注于两个主要特性：一个新的反应式客户端 API，以及对服务器发送的事件的支持。</p>
<h4 id="反应式客户端-API"><a href="#反应式客户端-API" class="headerlink" title="反应式客户端 API"></a>反应式客户端 API</h4><p>RESTful Web Services 自 1.1 版开始就包含一个客户端 API，提供了一种访问 Web 资源的高级方式。JAX-RS 2.1 向此 API 添加了反应式编程支持。最明显的区别是  Invocation.Builder ，它被用于构造客户端实例。如清单 14 所示，新的  rx()  方法具有一个返回类型  CompletionStage  和参数化类型  Response ：</p>
<h5 id="清单-14-包含新-rx-方法的调用构建器"><a href="#清单-14-包含新-rx-方法的调用构建器" class="headerlink" title="清单 14. 包含新 rx() 方法的调用构建器"></a>清单 14. 包含新 rx() 方法的调用构建器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CompletionStage&lt;Response &gt; cs1 = ClientBuilder.newClient()</span><br><span class="line">  .target(<span class="string">"http://localhost:8080/jax-rs-2-1/books"</span>)           </span><br><span class="line">  .request()       </span><br><span class="line">  .rx()         </span><br><span class="line">  .get();</span><br></pre></td></tr></table></figure>

<p> CompletionStage  接口是在 Java 8 中引入的，它提供了一些有用的可能性。在清单 15 中，对不同端点执行了两次调用并组合了结果：</p>
<h5 id="清单-15-调用不同端点后的组合结果"><a href="#清单-15-调用不同端点后的组合结果" class="headerlink" title="清单 15. 调用不同端点后的组合结果"></a>清单 15. 调用不同端点后的组合结果</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> CompletionStage&lt;  Response  &gt; cs1 = </span><br><span class="line">   <span class="comment">// from Listing 14  </span></span><br><span class="line">   CompletionStage&lt;Response &gt; cs2 = ClientBuilder.newClient()</span><br><span class="line">   .target(<span class="string">"http://localhost:8080/jax-rs-2-1/magazines"</span>)           </span><br><span class="line">   .request()</span><br><span class="line">   .rx()</span><br><span class="line">   .get();</span><br><span class="line">cs1.thenCombine(cs2, (r1, r2) -&gt;</span><br><span class="line">                r1.readEntity(String<span class="class">.<span class="keyword">class</span>) + <span class="title">r2</span>.<span class="title">readEntity</span>(<span class="title">String</span>.<span class="title">class</span>)) </span></span><br><span class="line">  .thenAccept(System.out::println);</span><br></pre></td></tr></table></figure>

<h4 id="服务器发送的事件"><a href="#服务器发送的事件" class="headerlink" title="服务器发送的事件"></a>服务器发送的事件</h4><p>Server Sent Events API (SSE) 由 W3C 在 HTML 5 中引入，并由 <a href="https://html.spec.whatwg.org/multipage/server-sent-events.html" target="_blank" rel="noopener">WHATWG 社区</a>维护，该 API 允许客户端订阅服务器生成的事件。在 SSE 架构中，创建了一条从服务器到客户端的单向通道，服务器可通过该通道发送多个事件。该连接长期存在并一直处于打开状态，直到一端关闭它。 JAX-RS API 包含一个用于 SSE 的客户端和服务器 API。来自客户端的入口点是  SseEventSource  接口，可以通过一个配置好的  WebTarget  来修改它，如清单 16 所示。在这段代码中，客户端注册了一个使用者。使用者输出到控制台，然后打开连接。 onComplete  和  onError  生命周期事件的处理函数也受到支持。</p>
<h5 id="清单-16-针对服务器发送的事件的-JAX-RS-客户端-API"><a href="#清单-16-针对服务器发送的事件的-JAX-RS-客户端-API" class="headerlink" title="清单 16. 针对服务器发送的事件的 JAX-RS 客户端 API"></a>清单 16. 针对服务器发送的事件的 JAX-RS 客户端 API</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">WebTarget target = ClientBuilder.newClient() </span><br><span class="line">   .target(<span class="string">"http://localhost:8080/jax-rs-2-1/sse/"</span>);</span><br><span class="line"><span class="keyword">try</span> (SseEventSource source = SseEventSource</span><br><span class="line">     .target(target).build()) &#123;     </span><br><span class="line">  source.register(System.out::println);</span><br><span class="line">  source.open();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在另一端，SSE 服务器 API 接受来自客户端的连接，并将事件发送到所有已连接的客户端：</p>
<h5 id="清单-17-用于服务器发送的事件的服务器-API"><a href="#清单-17-用于服务器发送的事件的服务器-API" class="headerlink" title="清单 17. 用于服务器发送的事件的服务器 API"></a>清单 17. 用于服务器发送的事件的服务器 API</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="meta">@POST</span>  </span><br><span class="line"><span class="meta">@Path</span>(<span class="string">"progress/&#123;report_id&#125;"</span>)  </span><br><span class="line"><span class="meta">@Produces</span>(MediaType.SERVER_SENT_EVENTS)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eventStream</span><span class="params">(@PathParam(<span class="string">"report_id"</span>)</span>String id,  </span></span><br><span class="line"><span class="function">                        @Context SseEventSink es,  </span></span><br><span class="line"><span class="function">                        @Context Sse sse) </span>&#123;        </span><br><span class="line">  executorService.execute(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      eventSink.send(</span><br><span class="line">        sse.newEventBuilder().name(<span class="string">"report-progress"</span>)</span><br><span class="line">        .data(String<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line">              "Commencing process for report " + id)</span><br><span class="line">        .build());                </span><br><span class="line">      es.send(sse.newEvent(<span class="string">"Progress"</span>, <span class="string">"25%"</span>));</span><br><span class="line">      Thread.sleep(<span class="number">500</span>); </span><br><span class="line">      es.send(sse.newEvent(<span class="string">"Progress"</span>, <span class="string">"50%"</span>));</span><br><span class="line">      Thread.sleep(<span class="number">500</span>);                </span><br><span class="line">      es.send(sse.newEvent(<span class="string">"Progress"</span>, <span class="string">"75%"</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;           </span><br><span class="line">      e.printStackTrace();        </span><br><span class="line">    &#125;       </span><br><span class="line">  &#125;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在清单 17 中，将  SseEventSink  和  Sse  资源注入到了 resource 方法中。 Sse  实例获取一个新的出站事件构建器，并将进度事件发送到客户端。请注意，介质类型为一个单独用于事件流的新  text/event-stream  类型。</p>
<h4 id="广播服务器发送的事件"><a href="#广播服务器发送的事件" class="headerlink" title="广播服务器发送的事件"></a>广播服务器发送的事件</h4><p>事件可同时广播到多个客户端。此操作是通过在  SseBroadcaster  上注册多个  SseEventSink  实例来实现的：</p>
<h5 id="清单-18-广播到所有已注册的订阅者"><a href="#清单-18-广播到所有已注册的订阅者" class="headerlink" title="清单 18. 广播到所有已注册的订阅者"></a>清单 18. 广播到所有已注册的订阅者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Path</span>(<span class="string">"/"</span>)</span><br><span class="line"><span class="meta">@Singleton</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SseResource</span> </span>&#123;         </span><br><span class="line">  <span class="meta">@Context</span>        </span><br><span class="line">  <span class="keyword">private</span> Sse sse;</span><br><span class="line">  <span class="keyword">private</span> SseBroadcaster broadcaster;</span><br><span class="line">  <span class="meta">@PostConstruct</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialise</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.broadcaster = sse.newBroadcaster();        </span><br><span class="line">  &#125;         </span><br><span class="line">  </span><br><span class="line">  <span class="meta">@GET</span>        </span><br><span class="line">  <span class="meta">@Path</span>(<span class="string">"subscribe"</span>)        </span><br><span class="line">  <span class="meta">@Produces</span>(MediaType.SERVER_SENT_EVENTS)        </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(@Context SseEventSink eventSink)</span> </span>&#123;  </span><br><span class="line">    eventSink.send(sse.newEvent(<span class="string">"You are subscribed"</span>));   </span><br><span class="line">    broadcaster.register(eventSink);</span><br><span class="line">  &#125;               </span><br><span class="line">  </span><br><span class="line">  <span class="meta">@POST</span>        </span><br><span class="line">  <span class="meta">@Path</span>(<span class="string">"broadcast"</span>)        </span><br><span class="line">  <span class="meta">@Consumes</span>(MediaType.APPLICATION_FORM_URLENCODED)        </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">broadcast</span><span class="params">(@FormParam(<span class="string">"message"</span>)</span> String message) </span>&#123;</span><br><span class="line">    broadcaster.broadcast(sse.newEvent(message));        </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>清单 18 中的示例接收 URI  /subscribe  上的一个订阅请求。该订阅请求会导致为该订阅者创建一个  SseEventSink  实例，然后使用  SseBroadcaster  向资源注册该实例。从提交到 URL  /broadcast  的网页表单中检索广播到所有订阅者的消息，然后通过 broadcast()  方法处理它。</p>
<h4 id="对-JAX-RS-2-1-的其他更新"><a href="#对-JAX-RS-2-1-的其他更新" class="headerlink" title="对 JAX-RS 2.1 的其他更新"></a>对 JAX-RS 2.1 的其他更新</h4><p>JAX-RS 2.1 还引入了其他一些值得提及的细微更改：</p>
<ul>
<li>Resource  方法现在支持使用  CompletionStage  作为一种返回类型。</li>
<li>添加了对 Java API for JSON Processing (JSON-P) 和 Java API for JSON Binding (JSON-B) 的全面支持。</li>
<li>支持对所有提供者使用  @Priority ，包括实体提供者 — MessageBodyReader  和  MessageBodyWriter 。</li>
<li>对于所有不支持 Java Concurrency Utilities API 的环境，删除了默认设置。</li>
</ul>
<h3 id="JavaServer-Faces-2-3"><a href="#JavaServer-Faces-2-3" class="headerlink" title="JavaServer Faces 2.3"></a>JavaServer Faces 2.3</h3><p>JavaServer Faces (JSF) 2.3 版的目的是包含社区请求的特性，以及更紧密地集成 CDI 和 websocket。该版本考虑了大量问题（最终数量达数百个），尝试纠正了许多细微但较为突出的问题。JSF 是一项成熟的技术，所以现在解决的问题都是以前很难解决的或次要的问题。在这些问题中，JSF 2.3 通过对 Java  Date/Time  类型和类级 bean 验证的支持，对 Java SE 8 进行了改进。要获得完整列表，建议下载[最终版本规范](<a href="http://download.oracle.com/otndocs/jcp/jsf-2_3-final-eval-spec/" target="_blank" rel="noopener">http://download.oracle.com/otndocs/jcp/jsf-2_3-final-eval-spec/</a> index.html)。</p>
<h4 id="JSF-2-3-中的服务器推送"><a href="#JSF-2-3-中的服务器推送" class="headerlink" title="JSF 2.3 中的服务器推送"></a>JSF 2.3 中的服务器推送</h4><p>JSF 2.3 集成了 Servlet 4.0 中的服务器推送支持。JSF 非常适合在服务器推送实现中识别所需的资源，现在已将它设置为在 RenderResponsePhase  生命周期阶段执行该任务。</p>
<h3 id="JSON-Processing-1-1"><a href="#JSON-Processing-1-1" class="headerlink" title="JSON Processing 1.1"></a>JSON Processing 1.1</h3><p>JSON-P 获得了一个单点版本，这使它能够跟上最新的 <a href="https://www.ietf.org/" target="_blank" rel="noopener">IEFT</a> 标准。这些标准包括 <a href="http://tools.ietf.org/html/rfc6901" target="_blank" rel="noopener">JSON Pointer</a>、<a href="http://tools.ietf.org/html/rfc6902" target="_blank" rel="noopener">JSON Patch</a> 和 <a href="http://tools.ietf.org/html/rfc7396" target="_blank" rel="noopener">JSON Merge Patch</a>。 通过在  javax.json.streams  中引入的新  JsonCollectors  类，查询 JSON 也得到了简化。</p>
<h4 id="JSON-Pointer"><a href="#JSON-Pointer" class="headerlink" title="JSON-Pointer"></a>JSON-Pointer</h4><p><em>JSON Pointer</em> 定义一个字符串表达式来识别 JSON 文档中的特定值。类似于用于识别 XML 中的片段的 <a href="https://www.w3.org/TR/WD-xptr" target="_blank" rel="noopener">XPointer</a>，JSON Pointer 引用了 JSON 文档中的值。例如，考虑清单 19 中的 JSON 文档， topics  数组中的第 2 个元素将通过 JSON 指针表达式  /topics/1  进行引用。</p>
<h5 id="清单-19-一个包含数组的-JSON-对象"><a href="#清单-19-一个包含数组的-JSON-对象" class="headerlink" title="清单 19. 一个包含数组的 JSON 对象"></a>清单 19. 一个包含数组的 JSON 对象</h5><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"topics"</span>: [<span class="string">"Cognitive"</span>, <span class="string">"Cloud"</span>, <span class="string">"Data"</span>, <span class="string">"IoT"</span>, <span class="string">"Java"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>入口 API 是  JsonPointer  接口。通过调用  Json  类上的静态工厂方法  createPointer() ，创建了一个实例。清单 20 中的代码段创建了一个  JsonPointer ，并引用了 topics 数组中的第 2 个元素：</p>
<h5 id="清单-20-JsonPointer-引用一个数组元素"><a href="#清单-20-JsonPointer-引用一个数组元素" class="headerlink" title="清单 20. JsonPointer 引用一个数组元素"></a>清单 20. JsonPointer 引用一个数组元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Json.createPointer(<span class="string">"/topics/1"</span>).getValue(jsonTopicData);</span><br></pre></td></tr></table></figure>

<p> JsonPointer  API 也可以通过  adding 、 replacing  和  removing  属性来修改 JSON 文档。清单 21 向 topics 列表添加了值“Big Data”：</p>
<h5 id="清单-21-使用-JsonPointer-向数组添加值"><a href="#清单-21-使用-JsonPointer-向数组添加值" class="headerlink" title="清单 21. 使用 JsonPointer 向数组添加值"></a>清单 21. 使用 JsonPointer 向数组添加值</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Json.createPointer(<span class="string">"/topics/0"</span>).add(jsonTopicData, Json.createValue(<span class="string">"Big Data"</span>));</span><br></pre></td></tr></table></figure>

<h4 id="JSON-Patch"><a href="#JSON-Patch" class="headerlink" title="JSON Patch"></a>JSON Patch</h4><p>JSON Patch 表达了应用于 JSON Pointer 符号中的目标 JSON 文档的一系列操作。它可以执行以下操作： add 、 copy 、 move 、 remove 、 replace  和  test 。  JsonPatchBuilder  接口是进入此 API 的网关，是利用  Json  类上的静态方法  createPatchBuilder()  创建的。JSON Pointer 表达式被传递给某个操作方法并应用于 JSON 文档。清单 22 展示了如何将 topics 数组中的第一个元素替换为值“Spring 5”：</p>
<h5 id="清单-22-替换了数组中的值的-JsonPatchBuilder"><a href="#清单-22-替换了数组中的值的-JsonPatchBuilder" class="headerlink" title="清单 22. 替换了数组中的值的 JsonPatchBuilder"></a>清单 22. 替换了数组中的值的 JsonPatchBuilder</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;Json.createPatchBuilder()&#96;&#96;    &#96;&#96;.replace(&quot;&#x2F;topics&#x2F;0&quot;, &quot;Spring 5&quot;)&#96;&#96;    &#96;&#96;.build()&#96;&#96;    &#96;&#96;.apply(jsonTopicData);&#96;</span><br></pre></td></tr></table></figure>

<p>多个操作可链接起来并按顺序应用于前一次的修订结果。</p>
<h4 id="JSON-Merge-Patch"><a href="#JSON-Merge-Patch" class="headerlink" title="JSON Merge Patch"></a>JSON Merge Patch</h4><p>JSON Merge Patch 是一个 JSON 文档，描述了将对目标 JSON 文档执行的一组更改。表 1 给出了 3 种可用的操作。</p>
<h5 id="表-1-选择合并修订操作"><a href="#表-1-选择合并修订操作" class="headerlink" title="表 1. 选择合并修订操作"></a>表 1. 选择合并修订操作</h5><table>
<thead>
<tr>
<th align="left">操作</th>
<th align="left">目标</th>
<th align="left">修订</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Replace</td>
<td align="left">{“color”:”blue”}</td>
<td align="left">{“color”:”red”}</td>
<td align="left">{“color”:”red”}</td>
</tr>
<tr>
<td align="left">Add</td>
<td align="left">{“color”:”blue”}</td>
<td align="left">{“color”:”red”}</td>
<td align="left">{“color”: null}</td>
</tr>
<tr>
<td align="left">Remove</td>
<td align="left">{“color”:”red”}</td>
<td align="left">{“color”:”blue”,”color”:”red”}</td>
<td align="left">{}</td>
</tr>
</tbody></table>
<p><code>Json</code> 类上的静态方法 <code>createMergePatch()</code> 提供了一个 <code>JsonMergePatch</code> 类型的实例，您可以向该实例传递修订操作。然后，向得到的 <code>JsonMergePatch</code> 实例的 <code>apply()</code> 方法传递目标 JSON 并应用该修订。清单 23 展示了如何执行表 1 中的 <code>replace</code> 操作。</p>
<h5 id="清单-23-使用-JSON-Merge-Patch-来替换值"><a href="#清单-23-使用-JSON-Merge-Patch-来替换值" class="headerlink" title="清单 23. 使用 JSON Merge Patch 来替换值"></a>清单 23. 使用 JSON Merge Patch 来替换值</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Json.createMergePatch(Json.createValue(<span class="string">"&#123;\"colour\":\"red\"&#125;"</span>)).apply(Json.createValue(<span class="string">"&#123;\"colour\":\"red\"&#125;"</span>));</span><br></pre></td></tr></table></figure>

<h4 id="JsonCollectors"><a href="#JsonCollectors" class="headerlink" title="JsonCollectors"></a>JsonCollectors</h4><p>由于 Java 8 向 <code>javax.json.streams</code> 包引入 <code>JsonCollectors</code> 类，查询 JSON 变得简单得多。清单 24 展示了如何按字母 <em>c</em> 过滤 <code>topics</code> 数组并将结果收集到一个 <code>JsonArray</code> 中。</p>
<h5 id="清单-24-使用-JsonCollectors-过滤数组并将结果收集到-JsonArray-中"><a href="#清单-24-使用-JsonCollectors-过滤数组并将结果收集到-JsonArray-中" class="headerlink" title="清单 24. 使用 JsonCollectors 过滤数组并将结果收集到 JsonArray 中"></a>清单 24. 使用 JsonCollectors 过滤数组并将结果收集到 JsonArray 中</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JsonArray topics = jsonObject.getJsonArray(<span class="string">"topics"</span>)</span><br><span class="line">  .stream()</span><br><span class="line">  .filter(jv -&gt;((JsonString)jv)</span><br><span class="line">          .getString()</span><br><span class="line">          .startsWith(<span class="string">"C"</span>)).collect(JsonCollectors</span><br><span class="line">          .toJsonArray());`</span><br></pre></td></tr></table></figure>

<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>Java EE 针对云进行了重新定位，计划的版本包含两部分，前半部分包含促进实现该目标的技术。Java EE 8 一面世，Java EE 9 的研发工作就会开始。目前的目标是在一年内发布 Java EE 9。 Java EE 9 开发路线图已包含对 Java EE Security API 的增强，这些增强将包含不适用于 Java EE Security 1.0 中的一些特性。开发人员也有望看到对云中企业开发的深化支持，看到更多 Java EE 技术将使用<a href="http://www.reactivemanifesto.org/" target="_blank" rel="noopener">反应式宣言</a>作为蓝图来提高灾备能力和可伸缩性。 我对 Java EE 9 的愿望清单包括针对微服务友好的技术的改进。两个将支持微服务的 API 是 Configuration API 1.0 (<a href="https://www.jcp.org/en/jsr/detail?id=382" target="_blank" rel="noopener">JSR 382</a>) 和 Health Check，二者都已添加到 Java EE 8 中，但正在考虑进行下一次更新。 最新<a href="https://blogs.oracle.com/theaquarium/opening-up-java-ee" target="_blank" rel="noopener">公告</a>表明 Eclipse 正在采用 Java EE，我也很高兴听到此消息。预计开源基础将促进来自供应商和开发人员的更广泛的社区参与。我们应当预料到 Java EE 的发布节奏将会加快，这个强大的企业规范将会得到持续增强。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">GuoTao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://tomones.github.io/2020/05/30/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/">https://tomones.github.io/2020/05/30/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://tomones.github.io" target="_blank">凌虚阁</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=null" async="async"></script></div></div><div class="post-reward"><button class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="http://cdn.andiycc.com/wechat.png" alt="微信" onclick="window.open('http://cdn.andiycc.com/wechat.png')"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="http://cdn.andiycc.com/alipay.png" alt="支付宝" onclick="window.open('http://cdn.andiycc.com/alipay.png')"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></button></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2020/05/30/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"><img class="next-cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Linux常用命令</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/05/30/Java-lang-NoClassdefFoundError-Could-Not-Initialize-Class-Sun-AWT-X11-XtoolKit异常解决/" title="Java.lang.NoClassdefFoundError: Could Not Initialize Class Sun.AWT.X11.XtoolKit异常解决"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-30</div><div class="relatedPosts_title">Java.lang.NoClassdefFoundError: Could Not Initialize Class Sun.AWT.X11.XtoolKit异常解决</div></div></a></div><div class="relatedPosts_item"><a href="/2020/05/30/Java中15种锁的介绍：公平锁，可重入锁，独享锁，互斥锁，乐观锁，分段锁，自旋锁等等/" title="Java中15种锁的介绍：公平锁，可重入锁，独享锁，互斥锁，乐观锁，分段锁，自旋锁等等"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-30</div><div class="relatedPosts_title">Java中15种锁的介绍：公平锁，可重入锁，独享锁，互斥锁，乐观锁，分段锁，自旋锁等等</div></div></a></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By GuoTao</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="简繁转换">簡</button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="ribbon_piao" mobile="true" src="/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="/js/third-party/click_heart.js"></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script></body></html>
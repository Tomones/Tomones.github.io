<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>凌虚阁</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tomones.github.io/"/>
  <updated>2020-05-30T15:34:19.674Z</updated>
  <id>https://tomones.github.io/</id>
  
  <author>
    <name>GuoTao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java8新特性总结</title>
    <link href="https://tomones.github.io/2020/05/30/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/"/>
    <id>https://tomones.github.io/2020/05/30/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/</id>
    <published>2020-05-30T15:18:23.000Z</published>
    <updated>2020-05-30T15:34:19.674Z</updated>
    
    <content type="html"><![CDATA[<p>万众期待的 Java™EE 8 即将发布。这是自 2013 年 6 月以来 Java 企业平台的首次发布，是分成两部分的发布中的前半部分（后一部分是 Java EE 9）。Oracle 对 Java EE 进行了战略性重新定位，重点关注一些支持云计算、微服务和反应式编程的技术。反应式编程现在正融入到许多 Java EE API 的架构中，而 JSON 交换格式为核心平台提供了支撑。 我们将大体了解 Java EE 8 中提供的主要特性。重点包括 API 更新和引入、对 HTTP/2 的新支持、反应式编程，以及 JSON。我们首先会介绍 Java EE 规范和升级，它们无疑将决定企业 Java 编程未来几年的发展方向。</p><h2 id="全新的-API-和更新的-API"><a href="#全新的-API-和更新的-API" class="headerlink" title="全新的 API 和更新的 API"></a>全新的 API 和更新的 API</h2><p>Java EE 8 向核心 API 引入了一些主要和次要更新，比如 Servlet 4.0 和 Context and Dependency Injection 2.0。还引入了两个新的 API —Java API for JSON Binding (<a href="https://www.jcp.org/en/jsr/detail?id=367" target="_blank" rel="noopener">JSR 367</a>) 和 Java EE Security API (<a href="https://www.jcp.org/en/jsr/detail?id=375" target="_blank" rel="noopener">JSR 375</a>)。我们首先介绍新的 API，然后探索对存在已久的 Java EE 规范的改动。</p><h2 id="JSON-Binding-API"><a href="#JSON-Binding-API" class="headerlink" title="JSON Binding API"></a>JSON Binding API</h2><p>新的 JSON Binding API (JSON-B) 支持在 Java 对象与<a href="https://tools.ietf.org/html/rfc7159" target="_blank" rel="noopener">兼容 RFC 7159 的</a> JSON 之间执行序列化和反序列化，同时维护与 JAXB (<a href="https://jcp.org/en/jsr/detail?id=222" target="_blank" rel="noopener">Java API for XML Binding 2.0</a>) 的一致性。它提供了从 Java 类和实例到符合公认约定的 JSON 文档的默认映射。 JSON-B xu 还允许开发人员自定义序列化和反序列化。您可以使用注释自定义各个类的这些流程，或者使用运行时配置构建器来开发自定义策略。后一种方法包括使用适配器来支持用户定义的自定义。JSON-B 与 Java API for JSON Processing (JSON-P) 1.1（本文后面将讨论）紧密集成。</p><h3 id="规范内容"><a href="#规范内容" class="headerlink" title="规范内容"></a>规范内容</h3><p>两个接口为新的 JSON Binding API 提供了入口： JsonbBinding  和  Jsonb 。</p><ul><li>JsonbBinding  提供了 JSON Binding API 的客户端访问点。为此，它通过根据所设置的配置和参数来构建  Jsonb  实例。</li><li>Jsonb  通过方法  toJson()  和  fromJson()  提供序列化和反序列化操作。</li></ul><p>JSON-B 还可以向插入的外部 JSON Binding 提供者描述功能，所以您不受 API 附带的绑定逻辑的限制。</p><h3 id="使用-JsonB-实现序列化和反序列化"><a href="#使用-JsonB-实现序列化和反序列化" class="headerlink" title="使用 JsonB 实现序列化和反序列化"></a>使用 JsonB 实现序列化和反序列化</h3><p>清单 1 首先序列化  Book  类  book  的实例，然后将其反序列化。</p><h5 id="清单-1-序列化和反序列化的最简单示例"><a href="#清单-1-序列化和反序列化的最简单示例" class="headerlink" title="清单 1. 序列化和反序列化的最简单示例"></a>清单 1. 序列化和反序列化的最简单示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String bookJson = JsonbBuilder.create().toJson(book);</span><br><span class="line">Book book = JsonbBuilder.create().fromJson(bookJson, Book<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><p>静态  create()  工厂方法返回一个  Jsonb  实例。您可以在该实例上调用许多重载的  toJson()  和  fromJson()  方法。另请注意，该规范没有强制要求来回等效转换：在上面的示例中，将  bookJson  字符串传入  fromJson()  方法中可能不会反序列化为一个等效对象。 JSON-B 还支持采用与对象大致相同的方式来绑定集合类与原语和/或实例数组 —包括多维数组。</p><h3 id="自定义-Jsonb"><a href="#自定义-Jsonb" class="headerlink" title="自定义 Jsonb"></a>自定义 Jsonb</h3><p>可通过为字段、JavaBeans 方法和类添加注释，对  Jsonb  方法的默认行为进行自定义。 例如，可以使用  @JsonbNillable  和  @JsonbPropertyOrder  注释来自定义 null 处理和属性顺序，该顺序应在类级别上进行自定义：</p><h5 id="清单-2-自定义-Jsonb"><a href="#清单-2-自定义-Jsonb" class="headerlink" title="清单 2. 自定义 Jsonb"></a>清单 2. 自定义 Jsonb</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonbNillable</span></span><br><span class="line"><span class="meta">@JsonbPropertyOrder</span>(PropertyOrderStrategy.REVERSE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Booklet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="meta">@JsonbProperty</span>(<span class="string">"cost"</span>)</span><br><span class="line">    <span class="meta">@JsonbNumberFormat</span>(<span class="string">"#0.00"</span>)</span><br><span class="line">    <span class="keyword">private</span> Float price;</span><br><span class="line">    <span class="keyword">private</span> Author author;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@JsonbTransient</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@JsonbTransient</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// price and author getters/setter removed for brevity</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方法  toJson()  会生成清单 3 中所示的 JSON 结构。</p><h5 id="清单-3-自定义的-JSON-结构"><a href="#清单-3-自定义的-JSON-结构" class="headerlink" title="清单 3. 自定义的 JSON 结构"></a>清单 3. 自定义的 JSON 结构</h5><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"cost"</span>: <span class="string">"10.00"</span>,</span><br><span class="line">    <span class="attr">"author"</span>: &#123;</span><br><span class="line">        <span class="attr">"firstName"</span>: <span class="string">"Alex"</span>,</span><br><span class="line">        <span class="attr">"lastName"</span>: <span class="string">"Theedom"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以选择通过运行时配置构建器  JsonbConfig  来执行自定义：</p><h5 id="清单-4-Jsonb-的运行时配置"><a href="#清单-4-Jsonb-的运行时配置" class="headerlink" title="清单 4. Jsonb 的运行时配置"></a>清单 4. Jsonb 的运行时配置</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JsonbConfig jsonbConfig = <span class="keyword">new</span> JsonbConfig()        </span><br><span class="line">  .withPropertyNamingStrategy(   </span><br><span class="line">  PropertyNamingStrategy.LOWER_CASE_WITH_DASHES)  </span><br><span class="line">  .withNullValues(<span class="keyword">true</span>)  </span><br><span class="line">  .withFormatting(<span class="keyword">true</span>);   </span><br><span class="line">Jsonb jsonb = JsonbBuilder.create(jsonbConfig);</span><br></pre></td></tr></table></figure><p>清单 4 将 JSON-B 配置为使用  LOWER_CASE_WITH_DASHES  约定，以便将 null 保留在它们所在的位置，并输出经过优化的 JSON。</p><h3 id="开源绑定"><a href="#开源绑定" class="headerlink" title="开源绑定"></a>开源绑定</h3><p>前面已经提到过，您不需要使用现成的 JSON-B 选项。清单 5 展示了如何配置开源绑定实现：</p><h5 id="清单-5-开源绑定配置"><a href="#清单-5-开源绑定配置" class="headerlink" title="清单 5. 开源绑定配置"></a>清单 5. 开源绑定配置</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JsonbBuilde r builder = JsonbBuilder.newBuilder(<span class="string">"aProvider"</span>);</span><br></pre></td></tr></table></figure><h2 id="Java-EE-Security-API"><a href="#Java-EE-Security-API" class="headerlink" title="Java EE Security API"></a>Java EE Security API</h2><p>新 Java EE Security API 的引入，是为了更正各种 servlet 容器在解决安全问题的方式上的不一致。这个问题在 Java Web 配置文件中尤为突出，主要是因为 Java EE 仅规定了完整的 Java EE 配置文件必须如何实现标准 API。新规范还引入了一些现有 API 没有利用的现代功能，比如 CDI。 这个 API 的美妙之处在于，它提供了一种配置身份存储和身份验证机制的备选方法，但没有取代现有安全机制。开发人员应该非常希望拥有在 Java EE Web 应用程序中启用安全性的机会，无论是否使用特定于供应商的解决方案或专用的解决方案。</p><h3 id="规范内容-1"><a href="#规范内容-1" class="headerlink" title="规范内容"></a>规范内容</h3><p>Java EE Security API 规范解决了 3 个关键问题：</p><ul><li>HttpAuthenticationMechanism  支持对 servlet 容器执行身份验证。</li><li>IdentityStore  标准化了 JAAS  LoginModule 。</li><li>SecurityContext  提供了一个实现编程安全的访问点。</li></ul><p>下面将介绍上述每个组件。</p><h3 id="HttpAuthenticationMechanism"><a href="#HttpAuthenticationMechanism" class="headerlink" title="HttpAuthenticationMechanism"></a>HttpAuthenticationMechanism</h3><p>Java EE 已指定了两种验证 Web 应用程序用户的机制：Java Servlet 规范 3.1 (JSR-340) 指定了一种声明性的应用程序配置机制，而 JASPIC (Java Authentication Service Provider Interface for Containers) 定义了一个名为  ServerAuthModule  的 SPI，该 SPI 支持开发身份验证模块来处理任何凭证类型。 这两种机制既有意义又很有效，但从 Web 应用程序开发人员的角度讲，每种机制都存在局限性。servlet 容器机制仅支持小范围的凭证类型。JASPIC 非常强大和灵活，但使用起来也非常复杂。 Java EE Security API 希望通过一个新接口解决这些问题： HttpAuthenticationMechanism 。这个新接口实际上是 JASPIC ServerAuthModule  接口的一个简化的 servlet 容器变体，它在减少现有机制的局限性的同时利用现有机制。  HttpAuthenticationMechanism  类型的实例是一个 CDI bean，可将它用于实现注入操作的容器，而且该实例被指定仅用于 servlet 容器。该规范明确排除了 EJB 和 JMS 等其他容器。  HttpAuthenticationMechanism  接口定义了 3 个方法： validateRequest() 、 secureResponse()  和  cleanSubject() 。这些方法非常类似于 JASPIC  ServerAuth  接口上声明的方法，所以开发人员应该对它们感到熟悉。唯一需要重写的方法是 validateRequest() ；其他所有方法都有默认实现。</p><h3 id="IdentityStore"><a href="#IdentityStore" class="headerlink" title="IdentityStore"></a>IdentityStore</h3><p><em>身份存储</em>是一个数据库，用于存储用户身份数据，比如用户名、组成员关系，以及用于验证凭证的信息。在新的 Java EE Security API 中，使用了一个名为  IdentityStore  的身份存储抽象来与身份存储进行交互。它的用途是验证用户并检索组成员信息。 正如规范中所写， IdentityStore  的意图是供  HttpAuthenticationMechanism  实现使用，不过这不是必须的。结合使用 IdentityStore  和  HttpAuthenticationMechanism ，使得应用程序能以一种便携的、标准的方式控制其身份存储。</p><h3 id="SecurityContext"><a href="#SecurityContext" class="headerlink" title="SecurityContext"></a>SecurityContext</h3><p> IdentityStore  和  HttpAuthenticationMechanism  相结合，成为了一个强大的新的用户身份验证工具。然而，声明性模型可能无法满足系统级安全需求。 SecurityContext  可在这里派上用场：编程安全使得 Web 应用程序能执行所需的测试，从而允许或拒绝访问应用程序资源。</p><h2 id="主要更新：Servlet-4-0、Bean-Validation-2-0、CDI-2-0"><a href="#主要更新：Servlet-4-0、Bean-Validation-2-0、CDI-2-0" class="headerlink" title="主要更新：Servlet 4.0、Bean Validation 2.0、CDI 2.0"></a>主要更新：Servlet 4.0、Bean Validation 2.0、CDI 2.0</h2><p>Java EE 8 中主要提供了 3 个企业标准 API：Servlet 4.0 (<a href="https://jcp.org/en/jsr/detail?id=369" target="_blank" rel="noopener">JSR 369</a>)、Bean Validation 2.0 (<a href="https://jcp.org/en/jsr/detail?id=380" target="_blank" rel="noopener">JSR 380</a>) 和 Contexts and Dependency Injection for Java 2.0 (<a href="https://jcp.org/en/jsr/detail?id=365" target="_blank" rel="noopener">JSR 365</a>)。 下面将介绍每个 API 的重要特性。</p><h3 id="Servlet-4-0"><a href="#Servlet-4-0" class="headerlink" title="Servlet 4.0"></a>Servlet 4.0</h3><p>Java Servlet API 是 Java 企业开发人员最早接触、最熟悉的 API 之一。它于 1999 年在 J2EE 1.2 中首次面世，现在在 Java Server Pages (JSP)、JavaServer Faces (JSF)、JAX-RS 和 MVC (<a href="https://jcp.org/en/jsr/detail?id=371" target="_blank" rel="noopener">JSR 371</a>) 中发挥着重要作用。 Java EE 8 中对 Servlet 进行了重大修订，主要是为了适应 [HTTP/2](<a href="https://www.ibm.com/developerworks/library/wa-http2-under-the-hood" target="_blank" rel="noopener">https://www.ibm.com/developerworks/library/wa-http2-under-the-hood</a> /index.html) 的性能增强特性。服务器推送目前是这一领域的首要特性。 <strong>服务器推送是什么？</strong> <em>服务器推送</em>通过将客户端资源推送到浏览器的缓存中来预先满足对这些资源的需求。客户端发送请求并收到服务器响应时，所需的资源已在缓存中。</p><h4 id="PushBuilder"><a href="#PushBuilder" class="headerlink" title="PushBuilder"></a>PushBuilder</h4><p>在 Servlet 4.0 中，服务器推送是通过一个  PushBuilder  实例公开的。清单 6 展示了一个从 HttpServletResponse  实例获取的  PushBuilder  实例，该实例被传递到一个请求处理方法。</p><h5 id="清单-6-servlet-中的-PushBuilder"><a href="#清单-6-servlet-中的-PushBuilder" class="headerlink" title="清单 6. servlet 中的 PushBuilder"></a>清单 6. servlet 中的 PushBuilder</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request,            </span></span></span><br><span class="line"><span class="function"><span class="params">                     HttpServletResponse response)</span>            </span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> ServletException, IOException </span>&#123;   </span><br><span class="line">  PushBuilder pushBuilder = request.newPushBuilder(); </span><br><span class="line">  pushBuilder.path(<span class="string">"images/header.png"</span>).push();  </span><br><span class="line">  pushBuilder.path(<span class="string">"css/menu.css"</span>).push(); </span><br><span class="line">  pushBuilder.path(<span class="string">"js/ajax.js"</span>).push(); </span><br><span class="line">  <span class="comment">// Do some processing and return JSP that   </span></span><br><span class="line">  <span class="comment">// requires these resources  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在清单 6 中， header.png  的路径是通过  path()  方法在  PushBuilder  实例上设置的，并通过调用  push()  推送到客户端。该方法返回时，会清除路径和条件标头，以供构建器重用。</p><h4 id="servlet-映射的运行时发现"><a href="#servlet-映射的运行时发现" class="headerlink" title="servlet 映射的运行时发现"></a>servlet 映射的运行时发现</h4><p>Servlet 4.0 提供了一个新的 API，用它来实现 URL 映射的运行时发现。 HttpServletMapping  接口的用途是让确定导致 servlet 激活的映射变得更容易。在该 API 内，会从一个  HttpServletRequest  实例获得 servlet 映射，该实例包含 4 个方法：</p><ul><li>getMappingMatch()  返回匹配的类型。</li><li>getPattern()  返回激活 servlet 请求的 URL 模式。</li><li>getMatchValue()  返回匹配的  String </li><li>getServletName()  返回通过该请求激活的 servlet 类的完全限定名称。</li></ul><h5 id="清单-7-HttpServletMapping-接口上的所有-4-个方法"><a href="#清单-7-HttpServletMapping-接口上的所有-4-个方法" class="headerlink" title="清单 7. HttpServletMapping 接口上的所有 4 个方法"></a>清单 7. HttpServletMapping 接口上的所有 4 个方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HttpServletMapping mapping = request.getHttpServletMapping();  </span><br><span class="line">String mapping = mapping.getMappingMatch().name();  </span><br><span class="line">String value = mapping.getMatchValue();  </span><br><span class="line">String pattern = mapping.getPattern();  </span><br><span class="line">String servletName = mapping.getServletName();</span><br></pre></td></tr></table></figure><p>除了这些更新之外，Servlet 4.0 还包含更细微的管理性更改和对 <a href="https://tools.ietf.org/html/rfc7230" target="_blank" rel="noopener">HTTP Trailer</a> 的支持。新的  GenericFilter  和  HttpFilter  类简化了过滤器的编写，实现了对 Java SE 8 的一般性改进。</p><h3 id="Bean-Validation-2-0"><a href="#Bean-Validation-2-0" class="headerlink" title="Bean Validation 2.0"></a>Bean Validation 2.0</h3><p>Bean Validation 2.0 通过一系列新特性得到了增强，其中许多特性是 Java 开发人员社区所请求的。Bean 验证是一个横切关注点，所以 2.0 版规范希望确保数据在从客户端传输到数据库的过程中是完整的，并通过对字段值、返回值和方法参数应用约束来实现此目的。 这些增强中包含一些约束，它们可以验证电子邮箱地址，确保数字是正的或负的，测试日期是过去还是现在，并测试字段不是空的或 null。这些约束包括： @Email 、 @Positive 、 @PositiveOrZero 、 @Negative 、 @NegativeOrZero 、 @PastOrPresent 、 @FutureOrPresent 、 @NotEmpty  和  @NotBlank 。这些约束现在也可应用于更广泛的地方。例如，它们可以继续处理参数化类型的参数。添加了对按类型参数来验证容器元素的支持，如清单 8 所示。</p><h5 id="清单-8-按类型验证容器元素"><a href="#清单-8-按类型验证容器元素" class="headerlink" title="清单 8. 按类型验证容器元素"></a>清单 8. 按类型验证容器元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;<span class="meta">@Size</span>(min = <span class="number">30</span>) String&gt; chapterTitles;</span><br></pre></td></tr></table></figure><p>更新后的 Bean Validation API 改进了 Java SE 8 的  Date  和  Time  类型，提供了对  java.util.Optional  的支持，如清单 9 所示。</p><h5 id="清单-9-Bean-Validation-2-0-支持-Date-和-Time-类型，以及-Optional"><a href="#清单-9-Bean-Validation-2-0-支持-Date-和-Time-类型，以及-Optional" class="headerlink" title="清单 9. Bean Validation 2.0 支持 Date 和 Time 类型，以及 Optional"></a>清单 9. Bean Validation 2.0 支持 Date 和 Time 类型，以及 Optional</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;<span class="meta">@Size</span>(min = <span class="number">10</span>) String&gt; title;  </span><br><span class="line"><span class="keyword">private</span> <span class="meta">@PastOrPresent</span> Year released;  </span><br><span class="line"><span class="keyword">private</span> <span class="meta">@FutureOrPresent</span> LocalDate nextVersionRelease;  </span><br><span class="line"><span class="keyword">private</span> <span class="meta">@Past</span> LocalDate publishedDate;</span><br></pre></td></tr></table></figure><p>容器的级联验证是一个很方便的新特性。使用  @Valid  对容器的任何类型参数进行注释，都会导致在验证父对象时验证每个元素。在清单 10 中，将会验证每个  String  和  Book  元素，如下所示：</p><h5 id="清单-10-容器类型的级联验证"><a href="#清单-10-容器类型的级联验证" class="headerlink" title="清单 10. 容器类型的级联验证"></a>清单 10. 容器类型的级联验证</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;<span class="meta">@Valid</span> String, <span class="meta">@Valid</span> Book&gt; otherBooksByAuthor;</span><br></pre></td></tr></table></figure><p>Bean Validation 还通过插入值提取器来添加对自定义容器类型的支持。内置的约束被标记为 repeatable，参数名是通过反射来检索的， ConstraintValidator#initialize()  是默认方法。JavaFX 还获得了对其类型的支持。</p><h3 id="Contexts-and-Dependency-Injection-for-Java-2-0"><a href="#Contexts-and-Dependency-Injection-for-Java-2-0" class="headerlink" title="Contexts and Dependency Injection for Java 2.0"></a>Contexts and Dependency Injection for Java 2.0</h3><p>Context and Dependency Injection API (CDI) 是一种自第 6 版开始就存在于 Java EE 中的主干技术。从那时起，它就成为了一个简化开发的关键特性。 在最新版本中，该 API 已扩展用于 Java SE。为了适应这一更改，CDI 规范被分解为 3 部分：第 1 部分处理 Java EE 和 Java SE 中的通用概念；第 2 部分处理仅针对 CDI with Java SE 的规则；第 3 部分处理仅针对 Java EE 的规则。 CDI 2.0 还对观察者和事件的行为及交互方式进行了重大更改。</p><h4 id="CDI-2-0-中的观察者和事件"><a href="#CDI-2-0-中的观察者和事件" class="headerlink" title="CDI 2.0 中的观察者和事件"></a>CDI 2.0 中的观察者和事件</h4><p>在 CDI 1.1 中，在触发事件时会同步调用观察者，没有任何机制来定义执行它们的顺序。此行为的问题在于，如果某个观察者抛出异常，则不会再调用所有后续观察者，观察者链将会中断。在 CDI 2.0 中，通过引入  @Priority  注释，从某种程度上减轻了这一问题，该注释指定了调用观察者应该采用的顺序，编号越小的观察者越先调用。 清单 11 展示了一次事件触发和两个具有不同优先级的观察者。观察者  AuditEventReciever1 （优先级为 10）在  AuditEventReciever2 （优先级为 100）前调用。</p><h5 id="清单-11-观察者优先级演示"><a href="#清单-11-观察者优先级演示" class="headerlink" title="清单 11. 观察者优先级演示"></a>清单 11. 观察者优先级演示</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inject</span>  </span><br><span class="line"><span class="keyword">private</span> Event&lt;AuditEvent&gt; event;   </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(AuditEvent auditEvent)</span> </span>&#123;       </span><br><span class="line">  event.fire(auditEvent);  &#125;   </span><br><span class="line"><span class="comment">// AuditEventReciever1.class  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(@Observes @Priority(<span class="number">10</span>)</span> AuditEvent auditEvent) </span>&#123;        </span><br><span class="line">  <span class="comment">// react to event </span></span><br><span class="line">&#125;   </span><br><span class="line">  <span class="comment">// AuditEventReciever2.class   </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(@Observes @Priority(<span class="number">100</span>)</span> AuditEvent auditEvent) </span>&#123;  </span><br><span class="line">  <span class="comment">// react to event </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，具有相同优先级的观察者会按无法预测的顺序进行调用，默认顺序为 javax.interceptor.Interceptor.Priority.APPLICATION + 500 。</p><h4 id="异步事件"><a href="#异步事件" class="headerlink" title="异步事件"></a>异步事件</h4><p>对观察者特性添加的另一个有用功能是，异步触发事件。添加了一个新触发方法 ( Async() ) 和相应的观察者注释 ( @ObservesAsyncfire ) 来支持此特性。清单 12 展示了一个异步调用的  AuditEvent ，以及收到该事件的通知的观察者方法。</p><h5 id="清单-12-异步触发事件"><a href="#清单-12-异步触发事件" class="headerlink" title="清单 12. 异步触发事件"></a>清单 12. 异步触发事件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inject</span>  </span><br><span class="line"><span class="keyword">private</span> Event&lt;AuditEvent&gt; event;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletionStage&lt;AuditEvent&gt; <span class="title">sendAsync</span><span class="params">(AuditEvent auditEvent)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> event.fireAsync(auditEvent);  </span><br><span class="line">&#125;   </span><br><span class="line"><span class="comment">// AuditEventReciever1.class  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveAsync</span><span class="params">(@ObservesAsync AuditEvent auditEvent)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;   </span><br><span class="line"><span class="comment">// AuditEventReciever2.class  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveAsync</span><span class="params">(@ObservesAsync AuditEvent auditEvent)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果任何观察者抛出异常， CompletionStage  就会包含  CompletionException 。这个实例包含对在观察者调用期间抛出的所有受抑制异常的引用。清单 13 展示了如何管理此场景。</p><h5 id="清单-13-管理异步观察者中的异常"><a href="#清单-13-管理异步观察者中的异常" class="headerlink" title="清单 13. 管理异步观察者中的异常"></a>清单 13. 管理异步观察者中的异常</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletionStage&lt;AuditEvent&gt; <span class="title">sendAsync</span><span class="params">(AuditEvent auditEvent)</span> </span>&#123;  </span><br><span class="line">  System.out.println(<span class="string">"Sending async"</span>);       </span><br><span class="line">  CompletionStage&lt;AuditEvent&gt; stage = event.fireAsync(auditEvent)   </span><br><span class="line">    .handle((event, ex) -&gt; &#123;           </span><br><span class="line">      <span class="keyword">if</span> (event != <span class="keyword">null</span>) &#123;    </span><br><span class="line">        <span class="keyword">return</span> event;      </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;                 </span><br><span class="line">        <span class="keyword">for</span> (Throwable t : ex.getSuppressed()) &#123;&#125;   </span><br><span class="line">        <span class="keyword">return</span> auditEvent;                   </span><br><span class="line">      &#125;              </span><br><span class="line">    &#125;);        </span><br><span class="line">  <span class="keyword">return</span> stage; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面已经提到过，CDI 2.0 还对一些 Java SE 8 特性进行了一般性改进，比如流、lambda 表达式和可重复的修饰符。其他值得注意的增添内容包括：</p><ul><li>一个新的  Configurators  接口。</li><li>配置或否决观察者方法的能力。</li><li>内置的注释文字。</li><li>在  producer  上应用  interceptor  的能力。</li></ul><p><a href="https://issues.jboss.org/secure/ReleaseNote.jspa?version%3D12325406%26styleName%3D%26projectId%3D12311062%26_sscc%3Dt" target="_blank" rel="noopener">这里</a>提供了所有更改的完整列表。请参阅规范的<a href="https://docs.jboss.org/cdi/spec/2.0-PFD/cdi-spec-with-assertions.html" target="_blank" rel="noopener">建议最终草案</a>了解完整细节。</p><h2 id="次要更新：JAX-RS-2-1、JSF-2-3、JSON-P-1-1"><a href="#次要更新：JAX-RS-2-1、JSF-2-3、JSON-P-1-1" class="headerlink" title="次要更新：JAX-RS 2.1、JSF 2.3、JSON-P 1.1"></a>次要更新：JAX-RS 2.1、JSF 2.3、JSON-P 1.1</h2><p>尽管是相对次要的更新，但对 Java API for RESTful Web Services (<a href="https://jcp.org/en/jsr/detail?id=370" target="_blank" rel="noopener">JSR 370</a>)、JavaServer Faces 2.3 (<a href="https://jcp.org/en/jsr/detail?id=372" target="_blank" rel="noopener">JSR 372</a>) 和 Java API for JSON Processing 1.1 (<a href="https://jcp.org/en/jsr/detail?id=374" target="_blank" rel="noopener">JSR 374</a>) 的更改仍值得注意，尤其应该注意反应式和函数式编程的元素。</p><h3 id="Java-API-for-RESTful-Web-Services-2-1"><a href="#Java-API-for-RESTful-Web-Services-2-1" class="headerlink" title="Java API for RESTful Web Services 2.1"></a>Java API for RESTful Web Services 2.1</h3><p>JAX-RS 2.1 API 版本专注于两个主要特性：一个新的反应式客户端 API，以及对服务器发送的事件的支持。</p><h4 id="反应式客户端-API"><a href="#反应式客户端-API" class="headerlink" title="反应式客户端 API"></a>反应式客户端 API</h4><p>RESTful Web Services 自 1.1 版开始就包含一个客户端 API，提供了一种访问 Web 资源的高级方式。JAX-RS 2.1 向此 API 添加了反应式编程支持。最明显的区别是  Invocation.Builder ，它被用于构造客户端实例。如清单 14 所示，新的  rx()  方法具有一个返回类型  CompletionStage  和参数化类型  Response ：</p><h5 id="清单-14-包含新-rx-方法的调用构建器"><a href="#清单-14-包含新-rx-方法的调用构建器" class="headerlink" title="清单 14. 包含新 rx() 方法的调用构建器"></a>清单 14. 包含新 rx() 方法的调用构建器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CompletionStage&lt;Response &gt; cs1 = ClientBuilder.newClient()</span><br><span class="line">  .target(<span class="string">"http://localhost:8080/jax-rs-2-1/books"</span>)           </span><br><span class="line">  .request()       </span><br><span class="line">  .rx()         </span><br><span class="line">  .get();</span><br></pre></td></tr></table></figure><p> CompletionStage  接口是在 Java 8 中引入的，它提供了一些有用的可能性。在清单 15 中，对不同端点执行了两次调用并组合了结果：</p><h5 id="清单-15-调用不同端点后的组合结果"><a href="#清单-15-调用不同端点后的组合结果" class="headerlink" title="清单 15. 调用不同端点后的组合结果"></a>清单 15. 调用不同端点后的组合结果</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> CompletionStage&lt;  Response  &gt; cs1 = </span><br><span class="line">   <span class="comment">// from Listing 14  </span></span><br><span class="line">   CompletionStage&lt;Response &gt; cs2 = ClientBuilder.newClient()</span><br><span class="line">   .target(<span class="string">"http://localhost:8080/jax-rs-2-1/magazines"</span>)           </span><br><span class="line">   .request()</span><br><span class="line">   .rx()</span><br><span class="line">   .get();</span><br><span class="line">cs1.thenCombine(cs2, (r1, r2) -&gt;</span><br><span class="line">                r1.readEntity(String<span class="class">.<span class="keyword">class</span>) + <span class="title">r2</span>.<span class="title">readEntity</span>(<span class="title">String</span>.<span class="title">class</span>)) </span></span><br><span class="line">  .thenAccept(System.out::println);</span><br></pre></td></tr></table></figure><h4 id="服务器发送的事件"><a href="#服务器发送的事件" class="headerlink" title="服务器发送的事件"></a>服务器发送的事件</h4><p>Server Sent Events API (SSE) 由 W3C 在 HTML 5 中引入，并由 <a href="https://html.spec.whatwg.org/multipage/server-sent-events.html" target="_blank" rel="noopener">WHATWG 社区</a>维护，该 API 允许客户端订阅服务器生成的事件。在 SSE 架构中，创建了一条从服务器到客户端的单向通道，服务器可通过该通道发送多个事件。该连接长期存在并一直处于打开状态，直到一端关闭它。 JAX-RS API 包含一个用于 SSE 的客户端和服务器 API。来自客户端的入口点是  SseEventSource  接口，可以通过一个配置好的  WebTarget  来修改它，如清单 16 所示。在这段代码中，客户端注册了一个使用者。使用者输出到控制台，然后打开连接。 onComplete  和  onError  生命周期事件的处理函数也受到支持。</p><h5 id="清单-16-针对服务器发送的事件的-JAX-RS-客户端-API"><a href="#清单-16-针对服务器发送的事件的-JAX-RS-客户端-API" class="headerlink" title="清单 16. 针对服务器发送的事件的 JAX-RS 客户端 API"></a>清单 16. 针对服务器发送的事件的 JAX-RS 客户端 API</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">WebTarget target = ClientBuilder.newClient() </span><br><span class="line">   .target(<span class="string">"http://localhost:8080/jax-rs-2-1/sse/"</span>);</span><br><span class="line"><span class="keyword">try</span> (SseEventSource source = SseEventSource</span><br><span class="line">     .target(target).build()) &#123;     </span><br><span class="line">  source.register(System.out::println);</span><br><span class="line">  source.open();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在另一端，SSE 服务器 API 接受来自客户端的连接，并将事件发送到所有已连接的客户端：</p><h5 id="清单-17-用于服务器发送的事件的服务器-API"><a href="#清单-17-用于服务器发送的事件的服务器-API" class="headerlink" title="清单 17. 用于服务器发送的事件的服务器 API"></a>清单 17. 用于服务器发送的事件的服务器 API</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="meta">@POST</span>  </span><br><span class="line"><span class="meta">@Path</span>(<span class="string">"progress/&#123;report_id&#125;"</span>)  </span><br><span class="line"><span class="meta">@Produces</span>(MediaType.SERVER_SENT_EVENTS)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eventStream</span><span class="params">(@PathParam(<span class="string">"report_id"</span>)</span>String id,  </span></span><br><span class="line"><span class="function">                        @Context SseEventSink es,  </span></span><br><span class="line"><span class="function">                        @Context Sse sse) </span>&#123;        </span><br><span class="line">  executorService.execute(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      eventSink.send(</span><br><span class="line">        sse.newEventBuilder().name(<span class="string">"report-progress"</span>)</span><br><span class="line">        .data(String<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line">              "Commencing process for report " + id)</span><br><span class="line">        .build());                </span><br><span class="line">      es.send(sse.newEvent(<span class="string">"Progress"</span>, <span class="string">"25%"</span>));</span><br><span class="line">      Thread.sleep(<span class="number">500</span>); </span><br><span class="line">      es.send(sse.newEvent(<span class="string">"Progress"</span>, <span class="string">"50%"</span>));</span><br><span class="line">      Thread.sleep(<span class="number">500</span>);                </span><br><span class="line">      es.send(sse.newEvent(<span class="string">"Progress"</span>, <span class="string">"75%"</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;           </span><br><span class="line">      e.printStackTrace();        </span><br><span class="line">    &#125;       </span><br><span class="line">  &#125;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在清单 17 中，将  SseEventSink  和  Sse  资源注入到了 resource 方法中。 Sse  实例获取一个新的出站事件构建器，并将进度事件发送到客户端。请注意，介质类型为一个单独用于事件流的新  text/event-stream  类型。</p><h4 id="广播服务器发送的事件"><a href="#广播服务器发送的事件" class="headerlink" title="广播服务器发送的事件"></a>广播服务器发送的事件</h4><p>事件可同时广播到多个客户端。此操作是通过在  SseBroadcaster  上注册多个  SseEventSink  实例来实现的：</p><h5 id="清单-18-广播到所有已注册的订阅者"><a href="#清单-18-广播到所有已注册的订阅者" class="headerlink" title="清单 18. 广播到所有已注册的订阅者"></a>清单 18. 广播到所有已注册的订阅者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Path</span>(<span class="string">"/"</span>)</span><br><span class="line"><span class="meta">@Singleton</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SseResource</span> </span>&#123;         </span><br><span class="line">  <span class="meta">@Context</span>        </span><br><span class="line">  <span class="keyword">private</span> Sse sse;</span><br><span class="line">  <span class="keyword">private</span> SseBroadcaster broadcaster;</span><br><span class="line">  <span class="meta">@PostConstruct</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialise</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.broadcaster = sse.newBroadcaster();        </span><br><span class="line">  &#125;         </span><br><span class="line">  </span><br><span class="line">  <span class="meta">@GET</span>        </span><br><span class="line">  <span class="meta">@Path</span>(<span class="string">"subscribe"</span>)        </span><br><span class="line">  <span class="meta">@Produces</span>(MediaType.SERVER_SENT_EVENTS)        </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(@Context SseEventSink eventSink)</span> </span>&#123;  </span><br><span class="line">    eventSink.send(sse.newEvent(<span class="string">"You are subscribed"</span>));   </span><br><span class="line">    broadcaster.register(eventSink);</span><br><span class="line">  &#125;               </span><br><span class="line">  </span><br><span class="line">  <span class="meta">@POST</span>        </span><br><span class="line">  <span class="meta">@Path</span>(<span class="string">"broadcast"</span>)        </span><br><span class="line">  <span class="meta">@Consumes</span>(MediaType.APPLICATION_FORM_URLENCODED)        </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">broadcast</span><span class="params">(@FormParam(<span class="string">"message"</span>)</span> String message) </span>&#123;</span><br><span class="line">    broadcaster.broadcast(sse.newEvent(message));        </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>清单 18 中的示例接收 URI  /subscribe  上的一个订阅请求。该订阅请求会导致为该订阅者创建一个  SseEventSink  实例，然后使用  SseBroadcaster  向资源注册该实例。从提交到 URL  /broadcast  的网页表单中检索广播到所有订阅者的消息，然后通过 broadcast()  方法处理它。</p><h4 id="对-JAX-RS-2-1-的其他更新"><a href="#对-JAX-RS-2-1-的其他更新" class="headerlink" title="对 JAX-RS 2.1 的其他更新"></a>对 JAX-RS 2.1 的其他更新</h4><p>JAX-RS 2.1 还引入了其他一些值得提及的细微更改：</p><ul><li>Resource  方法现在支持使用  CompletionStage  作为一种返回类型。</li><li>添加了对 Java API for JSON Processing (JSON-P) 和 Java API for JSON Binding (JSON-B) 的全面支持。</li><li>支持对所有提供者使用  @Priority ，包括实体提供者 — MessageBodyReader  和  MessageBodyWriter 。</li><li>对于所有不支持 Java Concurrency Utilities API 的环境，删除了默认设置。</li></ul><h3 id="JavaServer-Faces-2-3"><a href="#JavaServer-Faces-2-3" class="headerlink" title="JavaServer Faces 2.3"></a>JavaServer Faces 2.3</h3><p>JavaServer Faces (JSF) 2.3 版的目的是包含社区请求的特性，以及更紧密地集成 CDI 和 websocket。该版本考虑了大量问题（最终数量达数百个），尝试纠正了许多细微但较为突出的问题。JSF 是一项成熟的技术，所以现在解决的问题都是以前很难解决的或次要的问题。在这些问题中，JSF 2.3 通过对 Java  Date/Time  类型和类级 bean 验证的支持，对 Java SE 8 进行了改进。要获得完整列表，建议下载[最终版本规范](<a href="http://download.oracle.com/otndocs/jcp/jsf-2_3-final-eval-spec/" target="_blank" rel="noopener">http://download.oracle.com/otndocs/jcp/jsf-2_3-final-eval-spec/</a> index.html)。</p><h4 id="JSF-2-3-中的服务器推送"><a href="#JSF-2-3-中的服务器推送" class="headerlink" title="JSF 2.3 中的服务器推送"></a>JSF 2.3 中的服务器推送</h4><p>JSF 2.3 集成了 Servlet 4.0 中的服务器推送支持。JSF 非常适合在服务器推送实现中识别所需的资源，现在已将它设置为在 RenderResponsePhase  生命周期阶段执行该任务。</p><h3 id="JSON-Processing-1-1"><a href="#JSON-Processing-1-1" class="headerlink" title="JSON Processing 1.1"></a>JSON Processing 1.1</h3><p>JSON-P 获得了一个单点版本，这使它能够跟上最新的 <a href="https://www.ietf.org/" target="_blank" rel="noopener">IEFT</a> 标准。这些标准包括 <a href="http://tools.ietf.org/html/rfc6901" target="_blank" rel="noopener">JSON Pointer</a>、<a href="http://tools.ietf.org/html/rfc6902" target="_blank" rel="noopener">JSON Patch</a> 和 <a href="http://tools.ietf.org/html/rfc7396" target="_blank" rel="noopener">JSON Merge Patch</a>。 通过在  javax.json.streams  中引入的新  JsonCollectors  类，查询 JSON 也得到了简化。</p><h4 id="JSON-Pointer"><a href="#JSON-Pointer" class="headerlink" title="JSON-Pointer"></a>JSON-Pointer</h4><p><em>JSON Pointer</em> 定义一个字符串表达式来识别 JSON 文档中的特定值。类似于用于识别 XML 中的片段的 <a href="https://www.w3.org/TR/WD-xptr" target="_blank" rel="noopener">XPointer</a>，JSON Pointer 引用了 JSON 文档中的值。例如，考虑清单 19 中的 JSON 文档， topics  数组中的第 2 个元素将通过 JSON 指针表达式  /topics/1  进行引用。</p><h5 id="清单-19-一个包含数组的-JSON-对象"><a href="#清单-19-一个包含数组的-JSON-对象" class="headerlink" title="清单 19. 一个包含数组的 JSON 对象"></a>清单 19. 一个包含数组的 JSON 对象</h5><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"topics"</span>: [<span class="string">"Cognitive"</span>, <span class="string">"Cloud"</span>, <span class="string">"Data"</span>, <span class="string">"IoT"</span>, <span class="string">"Java"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>入口 API 是  JsonPointer  接口。通过调用  Json  类上的静态工厂方法  createPointer() ，创建了一个实例。清单 20 中的代码段创建了一个  JsonPointer ，并引用了 topics 数组中的第 2 个元素：</p><h5 id="清单-20-JsonPointer-引用一个数组元素"><a href="#清单-20-JsonPointer-引用一个数组元素" class="headerlink" title="清单 20. JsonPointer 引用一个数组元素"></a>清单 20. JsonPointer 引用一个数组元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Json.createPointer(<span class="string">"/topics/1"</span>).getValue(jsonTopicData);</span><br></pre></td></tr></table></figure><p> JsonPointer  API 也可以通过  adding 、 replacing  和  removing  属性来修改 JSON 文档。清单 21 向 topics 列表添加了值“Big Data”：</p><h5 id="清单-21-使用-JsonPointer-向数组添加值"><a href="#清单-21-使用-JsonPointer-向数组添加值" class="headerlink" title="清单 21. 使用 JsonPointer 向数组添加值"></a>清单 21. 使用 JsonPointer 向数组添加值</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Json.createPointer(<span class="string">"/topics/0"</span>).add(jsonTopicData, Json.createValue(<span class="string">"Big Data"</span>));</span><br></pre></td></tr></table></figure><h4 id="JSON-Patch"><a href="#JSON-Patch" class="headerlink" title="JSON Patch"></a>JSON Patch</h4><p>JSON Patch 表达了应用于 JSON Pointer 符号中的目标 JSON 文档的一系列操作。它可以执行以下操作： add 、 copy 、 move 、 remove 、 replace  和  test 。  JsonPatchBuilder  接口是进入此 API 的网关，是利用  Json  类上的静态方法  createPatchBuilder()  创建的。JSON Pointer 表达式被传递给某个操作方法并应用于 JSON 文档。清单 22 展示了如何将 topics 数组中的第一个元素替换为值“Spring 5”：</p><h5 id="清单-22-替换了数组中的值的-JsonPatchBuilder"><a href="#清单-22-替换了数组中的值的-JsonPatchBuilder" class="headerlink" title="清单 22. 替换了数组中的值的 JsonPatchBuilder"></a>清单 22. 替换了数组中的值的 JsonPatchBuilder</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;Json.createPatchBuilder()&#96;&#96;    &#96;&#96;.replace(&quot;&#x2F;topics&#x2F;0&quot;, &quot;Spring 5&quot;)&#96;&#96;    &#96;&#96;.build()&#96;&#96;    &#96;&#96;.apply(jsonTopicData);&#96;</span><br></pre></td></tr></table></figure><p>多个操作可链接起来并按顺序应用于前一次的修订结果。</p><h4 id="JSON-Merge-Patch"><a href="#JSON-Merge-Patch" class="headerlink" title="JSON Merge Patch"></a>JSON Merge Patch</h4><p>JSON Merge Patch 是一个 JSON 文档，描述了将对目标 JSON 文档执行的一组更改。表 1 给出了 3 种可用的操作。</p><h5 id="表-1-选择合并修订操作"><a href="#表-1-选择合并修订操作" class="headerlink" title="表 1. 选择合并修订操作"></a>表 1. 选择合并修订操作</h5><table><thead><tr><th align="left">操作</th><th align="left">目标</th><th align="left">修订</th><th align="left">结果</th></tr></thead><tbody><tr><td align="left">Replace</td><td align="left">{“color”:”blue”}</td><td align="left">{“color”:”red”}</td><td align="left">{“color”:”red”}</td></tr><tr><td align="left">Add</td><td align="left">{“color”:”blue”}</td><td align="left">{“color”:”red”}</td><td align="left">{“color”: null}</td></tr><tr><td align="left">Remove</td><td align="left">{“color”:”red”}</td><td align="left">{“color”:”blue”,”color”:”red”}</td><td align="left">{}</td></tr></tbody></table><p><code>Json</code> 类上的静态方法 <code>createMergePatch()</code> 提供了一个 <code>JsonMergePatch</code> 类型的实例，您可以向该实例传递修订操作。然后，向得到的 <code>JsonMergePatch</code> 实例的 <code>apply()</code> 方法传递目标 JSON 并应用该修订。清单 23 展示了如何执行表 1 中的 <code>replace</code> 操作。</p><h5 id="清单-23-使用-JSON-Merge-Patch-来替换值"><a href="#清单-23-使用-JSON-Merge-Patch-来替换值" class="headerlink" title="清单 23. 使用 JSON Merge Patch 来替换值"></a>清单 23. 使用 JSON Merge Patch 来替换值</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Json.createMergePatch(Json.createValue(<span class="string">"&#123;\"colour\":\"red\"&#125;"</span>)).apply(Json.createValue(<span class="string">"&#123;\"colour\":\"red\"&#125;"</span>));</span><br></pre></td></tr></table></figure><h4 id="JsonCollectors"><a href="#JsonCollectors" class="headerlink" title="JsonCollectors"></a>JsonCollectors</h4><p>由于 Java 8 向 <code>javax.json.streams</code> 包引入 <code>JsonCollectors</code> 类，查询 JSON 变得简单得多。清单 24 展示了如何按字母 <em>c</em> 过滤 <code>topics</code> 数组并将结果收集到一个 <code>JsonArray</code> 中。</p><h5 id="清单-24-使用-JsonCollectors-过滤数组并将结果收集到-JsonArray-中"><a href="#清单-24-使用-JsonCollectors-过滤数组并将结果收集到-JsonArray-中" class="headerlink" title="清单 24. 使用 JsonCollectors 过滤数组并将结果收集到 JsonArray 中"></a>清单 24. 使用 JsonCollectors 过滤数组并将结果收集到 JsonArray 中</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JsonArray topics = jsonObject.getJsonArray(<span class="string">"topics"</span>)</span><br><span class="line">  .stream()</span><br><span class="line">  .filter(jv -&gt;((JsonString)jv)</span><br><span class="line">          .getString()</span><br><span class="line">          .startsWith(<span class="string">"C"</span>)).collect(JsonCollectors</span><br><span class="line">          .toJsonArray());`</span><br></pre></td></tr></table></figure><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>Java EE 针对云进行了重新定位，计划的版本包含两部分，前半部分包含促进实现该目标的技术。Java EE 8 一面世，Java EE 9 的研发工作就会开始。目前的目标是在一年内发布 Java EE 9。 Java EE 9 开发路线图已包含对 Java EE Security API 的增强，这些增强将包含不适用于 Java EE Security 1.0 中的一些特性。开发人员也有望看到对云中企业开发的深化支持，看到更多 Java EE 技术将使用<a href="http://www.reactivemanifesto.org/" target="_blank" rel="noopener">反应式宣言</a>作为蓝图来提高灾备能力和可伸缩性。 我对 Java EE 9 的愿望清单包括针对微服务友好的技术的改进。两个将支持微服务的 API 是 Configuration API 1.0 (<a href="https://www.jcp.org/en/jsr/detail?id=382" target="_blank" rel="noopener">JSR 382</a>) 和 Health Check，二者都已添加到 Java EE 8 中，但正在考虑进行下一次更新。 最新<a href="https://blogs.oracle.com/theaquarium/opening-up-java-ee" target="_blank" rel="noopener">公告</a>表明 Eclipse 正在采用 Java EE，我也很高兴听到此消息。预计开源基础将促进来自供应商和开发人员的更广泛的社区参与。我们应当预料到 Java EE 的发布节奏将会加快，这个强大的企业规范将会得到持续增强。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;万众期待的 Java™EE 8 即将发布。这是自 2013 年 6 月以来 Java 企业平台的首次发布，是分成两部分的发布中的前半部分（后一部分是 Java EE 9）。Oracle 对 Java EE 进行了战略性重新定位，重点关注一些支持云计算、微服务和反应式编程的技
      
    
    </summary>
    
    
    
      <category term="Java" scheme="https://tomones.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="https://tomones.github.io/2020/05/30/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://tomones.github.io/2020/05/30/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2020-05-30T15:17:11.000Z</published>
    <updated>2020-07-20T15:15:21.505Z</updated>
    
    <content type="html"><![CDATA[<h3 id="keytool操作JDK密钥库"><a href="#keytool操作JDK密钥库" class="headerlink" title="keytool操作JDK密钥库"></a>keytool操作JDK密钥库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">导入证书</span></span><br><span class="line">keytool -import -v -trustcacerts -alias dandian -file /application/IDP/dandian.cer  -storepass  changeit  -keystore %JAVA_HOME%/jre/lib/security/cacerts</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查询证书库</span></span><br><span class="line">keytool -list -keystore cacerts </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">删除证书</span></span><br><span class="line">keytool -delete -alias dandian -keystore cacerts</span><br></pre></td></tr></table></figure><h3 id="服务器远程复制文件"><a href="#服务器远程复制文件" class="headerlink" title="服务器远程复制文件"></a>服务器远程复制文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">scp 当前要复制的文件名 远程主机上的用户名@远程主机IP：要复制到远程主机上哪个文件夹中</span></span><br><span class="line"></span><br><span class="line">scp adserver.cer root@10.213.70.53:/application/IDP/apache-tomcat-8.0.50</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -r 递归整个待复制的目录</span></span><br><span class="line">scp -r /application/IDP root@10.213.70.53:/application/IDP/apache-tomcat-8.0.50</span><br></pre></td></tr></table></figure><h3 id="卸载Linux自带OpenJDk"><a href="#卸载Linux自带OpenJDk" class="headerlink" title="卸载Linux自带OpenJDk"></a>卸载Linux自带OpenJDk</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看java版本</span></span><br><span class="line">[root@CFDB2 ~]# java -version</span><br><span class="line">openjdk version "1.8.0_171"</span><br><span class="line">OpenJDK Runtime Environment (build 1.8.0_171-b10)</span><br><span class="line">OpenJDK 64-Bit Server VM (build 25.171-b10, mixed mode)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看java安装软件</span></span><br><span class="line">[root@CFDB2 ~]# rpm -qa|grep java</span><br><span class="line">tzdata-java-2018e-3.el7.noarch</span><br><span class="line">java-1.8.0-openjdk-1.8.0.171-8.b10.el7_5.x86_64</span><br><span class="line">java-1.7.0-openjdk-headless-1.7.0.181-2.6.14.8.el7_5.x86_64</span><br><span class="line">java-1.7.0-openjdk-1.7.0.181-2.6.14.8.el7_5.x86_64</span><br><span class="line">javapackages-tools-3.4.1-11.el7.noarch</span><br><span class="line">python-javapackages-3.4.1-11.el7.noarch</span><br><span class="line">java-1.8.0-openjdk-headless-1.8.0.171-8.b10.el7_5.x86_64</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 卸载openjdk</span></span><br><span class="line">rpm -e --nodeps java-1.8.0-openjdk-headless-1.8.0.101-3.b13.el7_2.x86_64</span><br></pre></td></tr></table></figure><h3 id="配置JDK8环境变量"><a href="#配置JDK8环境变量" class="headerlink" title="配置JDK8环境变量"></a>配置JDK8环境变量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> vi /etc/profile</span></span><br><span class="line">export JAVA_HOME=/usr/share/jdk1.6.0_14</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">source</span> /etc/profile</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;keytool操作JDK密钥库&quot;&gt;&lt;a href=&quot;#keytool操作JDK密钥库&quot; class=&quot;headerlink&quot; title=&quot;keytool操作JDK密钥库&quot;&gt;&lt;/a&gt;keytool操作JDK密钥库&lt;/h3&gt;&lt;figure class=&quot;highli
      
    
    </summary>
    
    
    
      <category term="Linux" scheme="https://tomones.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Java.lang.NoClassdefFoundError: Could Not Initialize Class Sun.AWT.X11.XtoolKit异常解决</title>
    <link href="https://tomones.github.io/2020/05/30/Java-lang-NoClassdefFoundError-Could-Not-Initialize-Class-Sun-AWT-X11-XtoolKit%E5%BC%82%E5%B8%B8%E8%A7%A3%E5%86%B3/"/>
    <id>https://tomones.github.io/2020/05/30/Java-lang-NoClassdefFoundError-Could-Not-Initialize-Class-Sun-AWT-X11-XtoolKit%E5%BC%82%E5%B8%B8%E8%A7%A3%E5%86%B3/</id>
    <published>2020-05-30T15:16:11.000Z</published>
    <updated>2020-05-30T15:16:43.111Z</updated>
    
    <content type="html"><![CDATA[<p>该问题的解决方法：<br>在Tomcat/bin/catalina.sh 中增加-Djava.awt.headless=true</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如下：</span><br><span class="line">JAVA_OPTS="$JAVA_OPTS -Djava.awt.headless=true"</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="http://andiycc.com/wp-content/uploads/2019/05/B74248D8-2721-4eab-B9EB-5DFFB5F40332.png" alt="img"></p><p>原因：<br>对于一个Java服务器来说经常要处理一些图形元素，例如地图的创建或者图形和图表等。这些API基本上总是需要运行一个X-server以便能使用AWT（Abstract Window Toolkit，抽象窗口工具集）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;该问题的解决方法：&lt;br&gt;在Tomcat/bin/catalina.sh 中增加-Djava.awt.headless=true&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;
      
    
    </summary>
    
    
    
      <category term="Java" scheme="https://tomones.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Ldap常见错误码</title>
    <link href="https://tomones.github.io/2020/05/30/Ldap%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E7%A0%81/"/>
    <id>https://tomones.github.io/2020/05/30/Ldap%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E7%A0%81/</id>
    <published>2020-05-30T15:12:45.000Z</published>
    <updated>2020-05-30T15:13:11.972Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">LDAP_SUCCESS = <span class="number">0</span> <span class="comment">//成功</span></span><br><span class="line">LDAP_OPERATIONS_ERROR = <span class="number">1</span> <span class="comment">//操作错误</span></span><br><span class="line">LDAP_PROTOCOL_ERROR = <span class="number">2</span> <span class="comment">//协议错误</span></span><br><span class="line">LDAP_TIME_LIMIT_EXCEEDED = <span class="number">3</span> <span class="comment">//超过最大时间限制</span></span><br><span class="line">LDAP_SIZE_LIMIT_EXCEEDED = <span class="number">4</span> <span class="comment">//超过最大返回条目数</span></span><br><span class="line">LDAP_COMPARE_FALSE = <span class="number">5</span> <span class="comment">//比较不匹配</span></span><br><span class="line">LDAP_COMPARE_TRUE = <span class="number">6</span> <span class="comment">//比较匹配</span></span><br><span class="line">LDAP_AUTH_METHOD_NOT_SUPPORTED = <span class="number">7</span> <span class="comment">//认证方法未被支持</span></span><br><span class="line">LDAP_STRONG_AUTH_REQUIRED = <span class="number">8</span> <span class="comment">//需要强认证</span></span><br><span class="line">LDAP_PARTIAL_RESULTS = <span class="number">9</span> <span class="comment">//null</span></span><br><span class="line">LDAP_REFERRAL = <span class="number">10</span> <span class="comment">//Referral</span></span><br><span class="line">LDAP_ADMIN_LIMIT_EXCEEDED = <span class="number">11</span> <span class="comment">//超出管理员权限</span></span><br><span class="line">LDAP_UNAVAILABLE_CRITICAL_EXTENSION = <span class="number">12</span> <span class="comment">//Critical扩展无效</span></span><br><span class="line">LDAP_CONFIDENTIALITY_REQUIRED = <span class="number">13</span> <span class="comment">//需要Confidentiality</span></span><br><span class="line">LDAP_SASL_BIND_IN_PROGRESS = <span class="number">14</span> <span class="comment">//需要SASL绑定</span></span><br><span class="line">LDAP_NO_SUCH_ATTRIBUTE = <span class="number">16</span> <span class="comment">//未找到该属性</span></span><br><span class="line">LDAP_UNDEFINED_ATTRIBUTE_TYPE = <span class="number">17</span> <span class="comment">//未定义的属性类型</span></span><br><span class="line">LDAP_INAPPROPRIATE_MATCHING = <span class="number">18</span> <span class="comment">//不适当的匹配</span></span><br><span class="line">LDAP_CONSTRAINT_VIOLATION = <span class="number">19</span> <span class="comment">//约束冲突</span></span><br><span class="line">LDAP_ATTRIBUTE_OR_value_EXISTS = <span class="number">20</span> <span class="comment">//属性或值已存在</span></span><br><span class="line">LDAP_INVALID_ATTRIBUTE_SYNTAX = <span class="number">21</span> <span class="comment">//无效的属性语法</span></span><br><span class="line">LDAP_NO_SUCH_OBJECT = <span class="number">32</span> <span class="comment">//未找到该对象</span></span><br><span class="line">LDAP_ALIAS_PROBLEM = <span class="number">33</span> <span class="comment">//别名有问题</span></span><br><span class="line">LDAP_INVALID_DN_SYNTAX = <span class="number">34</span> <span class="comment">//无效的DN语法</span></span><br><span class="line">LDAP_IS_LEAF = <span class="number">35</span> <span class="comment">//null</span></span><br><span class="line">LDAP_ALIAS_DEREFERENCING_PROBLEM = <span class="number">36</span> <span class="comment">//Dereference别名有问题</span></span><br><span class="line">LDAP_INAPPROPRIATE_AUTHENTICATION = <span class="number">48</span> <span class="comment">//不适当的认证</span></span><br><span class="line">LDAP_INVALID_CREDENTIALS = <span class="number">49</span> <span class="comment">//无效的Credential</span></span><br><span class="line">LDAP_INSUFFICIENT_ACCESS_RIGHTS = <span class="number">50</span> <span class="comment">//访问权限不够</span></span><br><span class="line">LDAP_BUSY = <span class="number">51</span> <span class="comment">//遇忙</span></span><br><span class="line">LDAP_UNAVAILABLE = <span class="number">52</span> <span class="comment">//无效</span></span><br><span class="line">LDAP_UNWILLING_TO_PERform = <span class="number">53</span> <span class="comment">//意外问题</span></span><br><span class="line">LDAP_LOOP_DETECT = <span class="number">54</span> <span class="comment">//发现死循环</span></span><br><span class="line">LDAP_NAMING_VIOLATION = <span class="number">64</span> <span class="comment">//命名冲突</span></span><br><span class="line">LDAP_OBJECT_CLASS_VIOLATION = <span class="number">65</span> <span class="comment">//对象类冲突</span></span><br><span class="line">LDAP_NOT_ALLOWED_ON_NON_LEAF = <span class="number">66</span> <span class="comment">//不允许在非叶结点执行此操作</span></span><br><span class="line">LDAP_NOT_ALLOWED_ON_RDN = <span class="number">67</span> <span class="comment">//不允许对RDN执行此操作</span></span><br><span class="line">LDAP_ENTRY_ALREADY_EXISTS = <span class="number">68</span> <span class="comment">//Entry已存在</span></span><br><span class="line">LDAP_OBJECT_CLASS_MODS_PROHIBITED = <span class="number">69</span> <span class="comment">//禁止更改对象类</span></span><br><span class="line">LDAP_AFFECTS_MULTIPLE_DSAS = <span class="number">71</span> <span class="comment">//null</span></span><br><span class="line">LDAP_OTHER = <span class="number">80</span> <span class="comment">//其它</span></span><br><span class="line">再来一份十六进制的，大家对照吧。</span><br><span class="line">下面是winldap.h文件中的定义的十六进制错误码，我给其中的绝大部分加上了从活动目录的书上看的汉语说明，。</span><br><span class="line">typedef <span class="keyword">enum</span></span><br><span class="line">Unknown macro: &#123;</span><br><span class="line">LDAP_SUCCESS = <span class="number">0x00</span>,<span class="comment">//操作成功</span></span><br><span class="line">LDAP_OPERATIONS_ERROR = <span class="number">0x01</span>,<span class="comment">//一个未指定的错误发生在处理LDAP请求的服务器上</span></span><br><span class="line">LDAP_PROTOCOL_ERROR = <span class="number">0x02</span>,<span class="comment">//服务器接受到一个没有正确格式化或顺序出错的包</span></span><br><span class="line">LDAP_TIMELIMIT_EXCEEDED = <span class="number">0x03</span>,<span class="comment">//操作上指定的时间限制被超出。这不同于服务器没有及时响应时的客户方检测到的超时错误</span></span><br><span class="line">LDAP_SIZELIMIT_EXCEEDED = <span class="number">0x04</span>,<span class="comment">//搜索返回的项数超过了管理限制或请求限制</span></span><br><span class="line">LDAP_COMPARE_FALSE = <span class="number">0x05</span>,<span class="comment">//LDAP比较函数(例如ldap_compare())返回FALSE</span></span><br><span class="line">LDAP_COMPARE_TRUE = <span class="number">0x06</span>,<span class="comment">//LDAP比较函数(例如ldap_compare())返回TRUE</span></span><br><span class="line">LDAP_AUTH_METHOD_NOT_SUPPORTED = <span class="number">0x07</span>,<span class="comment">//绑定(bind)操作中(例如ldap_bind())请求的认证方法不被服务器支持。如果你使用一个非微软LDAP客户与活动目录通信，这种情况可能发生</span></span><br><span class="line">LDAP_STRONG_AUTH_REQUIRED = <span class="number">0x08</span>,<span class="comment">//服务器要求一个字符串认证方法而不是一个简单口令</span></span><br><span class="line">LDAP_REFERRAL_V2 = <span class="number">0x09</span>,<span class="comment">//搜索结果包含LDAPv2引用或者一个部分结果集</span></span><br><span class="line">LDAP_PARTIAL_RESULTS = <span class="number">0x09</span>,</span><br><span class="line">LDAP_REFERRAL = <span class="number">0x0a</span>,<span class="comment">//请求操作必须由另一个拥有适当的命名上下文备份的服务器处理</span></span><br><span class="line">LDAP_ADMIN_LIMIT_EXCEEDED = <span class="number">0x0b</span>,<span class="comment">//管理限制被超出。例如，搜索操作花费的时间超出了服务器所允许的最大时间</span></span><br><span class="line">LDAP_UNAVAILABLE_CRIT_EXTENSION = <span class="number">0x0c</span>,<span class="comment">//客户请求一个LDAP扩展并且指示该扩展是关键的，但是服务器并不支持扩展</span></span><br><span class="line">LDAP_CONFIDENTIALITY_REQUIRED = <span class="number">0x0d</span>,<span class="comment">//操作要求某种级别的加密</span></span><br><span class="line">LDAP_SASL_BIND_IN_PROGRESS = <span class="number">0x0e</span>,<span class="comment">//当一个SASL绑定(bind)已经在客户处理过程中时，请求一个绑定(bind)操作</span></span><br><span class="line">LDAP_NO_SUCH_ATTRIBUTE = <span class="number">0x10</span>,<span class="comment">//客户尝试修改或者删除一个并不存在的项的一个属性</span></span><br><span class="line">LDAP_UNDEFINED_TYPE = <span class="number">0x11</span>,<span class="comment">//未定义的类型</span></span><br><span class="line">LDAP_INAPPROPRIATE_MATCHING = <span class="number">0x12</span>,<span class="comment">//提供的匹配规则对搜索不合适或者对于属性不合适</span></span><br><span class="line">LDAP_CONSTRAINT_VIOLATION = <span class="number">0x13</span>,<span class="comment">//客户请求一个将违背目录中语义约束的操作。一个经常的原因是不合适的改变了模式--例如当添加一个新类时提供了一个重复的OID(对象识别符)</span></span><br><span class="line">LDAP_ATTRIBUTE_OR_value_EXISTS = <span class="number">0x14</span>,<span class="comment">//客户尝试添加一个已经存在的属性或值</span></span><br><span class="line">LDAP_INVALID_SYNTAX = <span class="number">0x15</span>,<span class="comment">//搜索过滤器的语法无效</span></span><br><span class="line">LDAP_NO_SUCH_OBJECT = <span class="number">0x20</span>,<span class="comment">//客户尝试或者删除一个在目录中并不存在的项</span></span><br><span class="line">LDAP_ALIAS_PROBLEM = <span class="number">0x21</span>,<span class="comment">//服务器在处理别名时遇到了一个错误</span></span><br><span class="line">LDAP_INVALID_DN_SYNTAX = <span class="number">0x22</span>,<span class="comment">//请求中指定的可区别名字的格式无效</span></span><br><span class="line">LDAP_IS_LEAF = <span class="number">0x23</span>,<span class="comment">//函数中指定的项是目录树中的一个叶子项</span></span><br><span class="line">LDAP_ALIAS_DEREF_PROBLEM = <span class="number">0x24</span>,<span class="comment">//在解除对一个别名的引用时服务器遇到了一个错误。例如，目的项并不存在</span></span><br><span class="line">LDAP_INAPPROPRIATE_AUTH = <span class="number">0x30</span>,<span class="comment">//认证级别对于操作不足</span></span><br><span class="line">LDAP_INVALID_CREDENTIALS = <span class="number">0x31</span>,<span class="comment">//绑定(bind)请求中提供的证书是无效的--例如一个无效的口令</span></span><br><span class="line">LDAP_INSUFFICIENT_RIGHTS = <span class="number">0x32</span>,<span class="comment">//没有执行该操作所需的足够的访问权限</span></span><br><span class="line">LDAP_BUSY = <span class="number">0x33</span>,<span class="comment">//服务器太忙碌而无法服务该请求。稍后重新尝试</span></span><br><span class="line">LDAP_UNAVAILABLE = <span class="number">0x34</span>,<span class="comment">//目录服务暂不可用。稍后重新尝试</span></span><br><span class="line">LDAP_UNWILLING_TO_PERform = <span class="number">0x35</span>,<span class="comment">//由于管理策略约束方面的原因，服务器将不支持该操作--例如，如果在模式修改没有被允许或者没有连接到模式管理器的情况下，试图修改该模式</span></span><br><span class="line">LDAP_LOOP_DETECT = <span class="number">0x36</span>,<span class="comment">//在追踪引用的过程中，客户引用到它以前已经引用的服务器</span></span><br><span class="line">LDAP_SORT_CONTROL_MISSING = <span class="number">0x3C</span>,</span><br><span class="line">LDAP_OFFSET_RANGE_ERROR = <span class="number">0x3D</span>,</span><br><span class="line">LDAP_NAMING_VIOLATION = <span class="number">0x40</span>,<span class="comment">//客户指定了一个不正确的对象的可区别名字</span></span><br><span class="line">LDAP_OBJECT_CLASS_VIOLATION = <span class="number">0x41</span>,<span class="comment">//操作违背了类定义中定义的语义规则</span></span><br><span class="line">LDAP_NOT_ALLOWED_ON_NONLEAF = <span class="number">0x42</span>,<span class="comment">//所请求的操作只可能在一个叶子对象(非容器)上执行</span></span><br><span class="line">LDAP_NOT_ALLOWED_ON_RDN = <span class="number">0x43</span>,<span class="comment">//在相对可区别名字上不允许该操作</span></span><br><span class="line">LDAP_ALREADY_EXISTS = <span class="number">0x44</span>,<span class="comment">//客户试图添加一个已经存在的对象</span></span><br><span class="line">LDAP_NO_OBJECT_CLASS_MODS = <span class="number">0x45</span>,<span class="comment">//客户试图通过改变一个对象的objectClass属性来修改对象的类</span></span><br><span class="line">LDAP_RESULTS_TOO_LARGE = <span class="number">0x46</span>,<span class="comment">//搜索操作的结果集太大，服务器无法处理</span></span><br><span class="line">LDAP_AFFECTS_MULTIPLE_DSAS = <span class="number">0x47</span>,<span class="comment">//所请求的操作将影响多个DSA--例如，在一个子树包含一个下级引用，该引用指向另一个命名上下文的情况下，删除该子树将影响多个DSA(目录服务器代理)</span></span><br><span class="line">LDAP_VIRTUAL_LIST_VIEW_ERROR = <span class="number">0x4c</span>,</span><br><span class="line">LDAP_OTHER = <span class="number">0x50</span>,<span class="comment">//发生了一些其他的LDAP错误</span></span><br><span class="line">LDAP_SERVER_DOWN = <span class="number">0x51</span>,<span class="comment">//LDAP服务器已关闭</span></span><br><span class="line">LDAP_LOCAL_ERROR = <span class="number">0x52</span>,<span class="comment">//客户发生了其他一些未指定的错误</span></span><br><span class="line">LDAP_ENCODING_ERROR = <span class="number">0x53</span>,<span class="comment">//在将一个LDAP请求编码为ASN.1的过程中发生了一个错误</span></span><br><span class="line">LDAP_DECODING_ERROR = <span class="number">0x54</span>,<span class="comment">//从服务器接受到的ASN.1编码的数据是无效的</span></span><br><span class="line">LDAP_TIMEOUT = <span class="number">0x55</span>,<span class="comment">//在指定的时间内服务器不能响应客户</span></span><br><span class="line">LDAP_AUTH_UNKNOWN = <span class="number">0x56</span>,<span class="comment">//在绑定(bind)请求中指定了一种未知的认证机制</span></span><br><span class="line">LDAP_FILTER_ERROR = <span class="number">0x57</span>,<span class="comment">//搜索过滤器出现了某种错误</span></span><br><span class="line">LDAP_USER_CANCELLED = <span class="number">0x58</span>,<span class="comment">//用户取消了操作</span></span><br><span class="line">LDAP_PARAM_ERROR = <span class="number">0x59</span>,<span class="comment">//函数中指定的某个参数出现了错误。例如，向一个LDAP API函数传递一个NULL指针，但该函数并不希望这样，在这种情况下就产生该错误</span></span><br><span class="line">LDAP_NO_MEMORY = <span class="number">0x5a</span>,<span class="comment">//客户试图分配内存并且失败了</span></span><br><span class="line">LDAP_CONNECT_ERROR = <span class="number">0x5b</span>,<span class="comment">//客户试图向服务器建立一个TCP连接并且失败了</span></span><br><span class="line">LDAP_NOT_SUPPORTED = <span class="number">0x5c</span>,<span class="comment">//所请求的操作不被这种版本的LDAP协议所支持</span></span><br><span class="line">LDAP_NO_RESULTS_RETURNED = <span class="number">0x5e</span>,<span class="comment">//从服务器接受到一个响应，但是它没有包含结果</span></span><br><span class="line">LDAP_CONTROL_NOT_FOUND = <span class="number">0x5d</span>,<span class="comment">//从服务器接受到的数据表明有一个LDAP控制出现但是在数据中没有找到一个LDAP控制</span></span><br><span class="line">LDAP_MORE_RESULTS_TO_RETURN = <span class="number">0x5f</span>,<span class="comment">//因为有太多的结果，所以客户无法检索</span></span><br><span class="line">LDAP_CLIENT_LOOP = <span class="number">0x60</span>,<span class="comment">//在处理引用时客户检测到一个循环</span></span><br><span class="line">引用数目超过了限制</span><br><span class="line">LDAP_REFERRAL_LIMIT_EXCEEDED = <span class="number">0x61</span><span class="comment">//客户追踪的</span></span><br><span class="line">&#125;</span><br><span class="line">LDAP_RETCODE;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
    
      <category term="LDAP" scheme="https://tomones.github.io/tags/LDAP/"/>
    
  </entry>
  
  <entry>
    <title>谈谈Redis的Setnx</title>
    <link href="https://tomones.github.io/2020/05/30/%E8%B0%88%E8%B0%88Redis%E7%9A%84Setnx/"/>
    <id>https://tomones.github.io/2020/05/30/%E8%B0%88%E8%B0%88Redis%E7%9A%84Setnx/</id>
    <published>2020-05-30T15:11:53.000Z</published>
    <updated>2020-05-30T15:12:18.879Z</updated>
    
    <content type="html"><![CDATA[<p>在 Redis 里，所谓SETNX是<br>「SET if Not exists」的缩写，也就是只有不存在的时候才设置，可以利用它来实现锁的效果，不过很多人没有意识到 SETNX 有陷阱！<br>比如说：某个查询数据库的接口，因为调用量比较大，所以加了缓存，并设定缓存过期后刷新，问题是当并发量比较大的时候，如果没有锁机制，那么缓存过期的瞬间，大量并发请求会穿透缓存直接查询数据库，造成雪崩效应，如果有锁机制，那么就可以控制只有一个请求去更新缓存，其它的请求视情况要么等待，要么使用过期的缓存。<br>下面以目前 PHP 社区里最流行的扩展为例，实现一段演示代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ok = $redis-&gt;setNX($key, $value);</span><br><span class="line"><span class="keyword">if</span> ($ok) &#123;</span><br><span class="line">    $cache-&gt;update();</span><br><span class="line">    $redis-&gt;del($key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缓存过期时，通过 SetNX 获取锁，如果成功了，那么更新缓存，然后删除锁。看上去逻辑非常简单，可惜有问题：如果请求执行因为某些原因意外退出了，导致创建了锁但是没有删除锁，那么这个锁将一直存在，以至于以后缓存再也得不到更新。于是乎我们需要给锁加一个过期时间以防不测：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$redis-&gt;multi();</span><br><span class="line">$redis-&gt;setNX($key, $value);</span><br><span class="line">$redis-&gt;expire($key, $ttl);</span><br><span class="line">$redis-&gt;exec();</span><br></pre></td></tr></table></figure><p>因为 SetNX 不具备设置过期时间的功能，所以我们需要借助Expire来设置，同时我们需要把两者用Multi/Exec包裹起来以确保请求的原子性，以免 SetNX 成功了 Expire 却失败了。 可惜还有问题：当多个请求到达时，虽然只有一个请求的 SetNX 可以成功，但是任何一个请求的 Expire 却都可以成功，如此就意味着即便获取不到锁，也可以刷新过期时间，如果请求比较密集的话，那么过期时间会一直被刷新，导致锁一直有效。于是乎我们需要在保证原子性的同时，有条件的执行 Expire，接着便有了如下 Lua 代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">local key   = KEYS[<span class="number">1</span>]</span><br><span class="line">local value = KEYS[<span class="number">2</span>]</span><br><span class="line">local ttl   = KEYS[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">local ok = redis.call(<span class="string">'setnx'</span>, key, value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ok == <span class="number">1</span> then</span><br><span class="line">  redis.call(<span class="string">'expire'</span>, key, ttl)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ok</span><br></pre></td></tr></table></figure><p>没想到实现一个看起来很简单的功能还要用到 Lua 脚本，着实有些麻烦。其实 Redis 已经考虑到了大家的疾苦，从 2.6.12 起，SET涵盖了 SETEX 的功能，并且 SET 本身已经包含了设置过期时间的功能，也就是说，我们前面需要的功能只用 SET 就可以实现。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ttl = <span class="number">60</span>;</span><br><span class="line">$ok = $redis-&gt;set($key, $value, <span class="keyword">array</span>(<span class="string">'nx'</span>, <span class="string">'ex'</span> =&gt; $ttl));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ($ok) &#123;</span><br><span class="line">    $cache-&gt;update();</span><br><span class="line">    $redis-&gt;del($key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里$ttl设置的时间要恰到好处，要大于请求执行的时间。</span></span><br></pre></td></tr></table></figure><p>如上代码是完美的吗？答案是还差一点！设想一下，如果一个请求更新缓存的时间比较长，甚至比锁的有效期还要长，导致在缓存更新过程中，锁就失效了，此时另一个请求会获取锁，但前一个请求在缓存更新完毕的时候，如果不加以判断直接删除锁，就会出现误删除其它请求创建的锁的情况，所以我们在创建锁的时候需要引入一个随机值：<br>//######最终判断加锁代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$random=mt_rand().uniqid(<span class="keyword">true</span>);</span><br><span class="line">$ok = $redis-&gt;set($key, $random, <span class="keyword">array</span>(<span class="string">'nx'</span>, <span class="string">'ex'</span> =&gt; $ttl));<span class="comment">//对查询进行加锁(一般是唯一数据项  例如订单号)</span></span><br><span class="line"><span class="keyword">if</span>($ok)&#123;</span><br><span class="line">    <span class="comment">//相当于业务这里一般来处理逻辑</span></span><br><span class="line">    $cache-&gt;update();<span class="comment">//更新缓存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ($redis-&gt;get($key) == $random) &#123; <span class="comment">//保证删自己的，别因为请求时间长而删掉别人的内容</span></span><br><span class="line">          $redis-&gt;del($key);<span class="comment">//处理完之后 释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充：本文在删除锁的时候，实际上是有问题的，没有考虑到 GC pause 之类的问题造成的影响，比如 A 请求在 DEL 之前卡住了，然后锁过期了，这时候 B 请求又成功获取到了锁，此时 A 请求缓过来了，就会 DEL 掉 B 请求创建的锁，此问题远比想象的要复杂.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 Redis 里，所谓SETNX是&lt;br&gt;「SET if Not exists」的缩写，也就是只有不存在的时候才设置，可以利用它来实现锁的效果，不过很多人没有意识到 SETNX 有陷阱！&lt;br&gt;比如说：某个查询数据库的接口，因为调用量比较大，所以加了缓存，并设定缓存过期后
      
    
    </summary>
    
    
    
      <category term="中间件" scheme="https://tomones.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java中15种锁的介绍：公平锁，可重入锁，独享锁，互斥锁，乐观锁，分段锁，自旋锁等等</title>
    <link href="https://tomones.github.io/2020/05/30/Java%E4%B8%AD15%E7%A7%8D%E9%94%81%E7%9A%84%E4%BB%8B%E7%BB%8D%EF%BC%9A%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%8C%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%8C%E7%8B%AC%E4%BA%AB%E9%94%81%EF%BC%8C%E4%BA%92%E6%96%A5%E9%94%81%EF%BC%8C%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%8C%E5%88%86%E6%AE%B5%E9%94%81%EF%BC%8C%E8%87%AA%E6%97%8B%E9%94%81%E7%AD%89%E7%AD%89/"/>
    <id>https://tomones.github.io/2020/05/30/Java%E4%B8%AD15%E7%A7%8D%E9%94%81%E7%9A%84%E4%BB%8B%E7%BB%8D%EF%BC%9A%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%8C%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%8C%E7%8B%AC%E4%BA%AB%E9%94%81%EF%BC%8C%E4%BA%92%E6%96%A5%E9%94%81%EF%BC%8C%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%8C%E5%88%86%E6%AE%B5%E9%94%81%EF%BC%8C%E8%87%AA%E6%97%8B%E9%94%81%E7%AD%89%E7%AD%89/</id>
    <published>2020-05-30T15:10:39.000Z</published>
    <updated>2020-05-30T15:11:18.816Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-中15种锁的介绍：公平锁，可重入锁，独享锁，互斥锁，乐观锁，分段锁，自旋锁等等"><a href="#Java-中15种锁的介绍：公平锁，可重入锁，独享锁，互斥锁，乐观锁，分段锁，自旋锁等等" class="headerlink" title="Java 中15种锁的介绍：公平锁，可重入锁，独享锁，互斥锁，乐观锁，分段锁，自旋锁等等"></a>Java 中15种锁的介绍：公平锁，可重入锁，独享锁，互斥锁，乐观锁，分段锁，自旋锁等等</h1><h2 id="Java-中15种锁的介绍"><a href="#Java-中15种锁的介绍" class="headerlink" title="Java 中15种锁的介绍"></a>Java 中15种锁的介绍</h2><p>在读很多并发文章中，会提及各种各样锁如公平锁，乐观锁等等，这篇文章介绍各种锁的分类。介绍的内容如下：</p><ul><li>公平锁 / 非公平锁</li><li>可重入锁 / 不可重入锁</li><li>独享锁 / 共享锁</li><li>互斥锁 / 读写锁</li><li>乐观锁 / 悲观锁</li><li>分段锁</li><li>偏向锁 / 轻量级锁 / 重量级锁</li><li>自旋锁</li></ul><p>上面是很多锁的名词，这些分类并不是全是指锁的状态，有的指锁的特性，有的指锁的设计，下面总结的内容是对每个锁的名词进行一定的解释。</p><h3 id="一、公平锁-非公平锁"><a href="#一、公平锁-非公平锁" class="headerlink" title="一、公平锁 / 非公平锁"></a>一、公平锁 / 非公平锁</h3><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>公平锁是指多个线程按照申请锁的顺序来获取锁。</p><h4 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h4><p>非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。</p><p>对于<code>Java ReentrantLock</code>而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。</p><p>对于<code>Synchronized</code>而言，也是一种非公平锁。由于其并不像<code>ReentrantLock</code>是通过<code>AQS</code>的来实现线程调度，所以并没有任何办法使其变成公平锁。</p><h3 id="二、可重入锁-不可重入锁"><a href="#二、可重入锁-不可重入锁" class="headerlink" title="二、可重入锁 / 不可重入锁"></a>二、可重入锁 / 不可重入锁</h3><h4 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h4><p>广义上的可重入锁指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁（前提得是同一个对象或者class），这样的锁就叫做可重入锁。<code>ReentrantLock</code>和<code>synchronized</code>都是可重入锁</p><p>Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    setB();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setB</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码就是一个可重入锁的一个特点，如果不是可重入锁的话，setB可能不会被当前线程执行，可能造成死锁。</p><h4 id="不可重入锁"><a href="#不可重入锁" class="headerlink" title="不可重入锁"></a>不可重入锁</h4><p>不可重入锁，与可重入锁相反，不可递归调用，递归调用就发生死锁。看到一个经典的讲解，使用自旋锁来模拟一个不可重入锁，代码如下</p><p>Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnreentrantLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Thread&gt; owner = <span class="keyword">new</span> AtomicReference&lt;Thread&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="comment">//这句是很经典的“自旋”语法，AtomicInteger中也有</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!owner.compareAndSet(<span class="keyword">null</span>, current)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        owner.compareAndSet(current, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码也比较简单，使用原子引用来存放线程，同一线程两次调用lock()方法，如果不执行unlock()释放锁的话，第二次调用自旋的时候就会产生死锁，这个锁就不是可重入的，而实际上同一个线程不必每次都去释放锁再来获取锁，这样的调度切换是很耗资源的。</p><p><strong>把它变成一个可重入锁：</strong></p><p>Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnreentrantLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Thread&gt; owner = <span class="keyword">new</span> AtomicReference&lt;Thread&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> state = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span> (current == owner.get()) &#123;</span><br><span class="line">            state++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这句是很经典的“自旋”式语法，AtomicInteger中也有</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!owner.compareAndSet(<span class="keyword">null</span>, current)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span> (current == owner.get()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (state != <span class="number">0</span>) &#123;</span><br><span class="line">                state--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                owner.compareAndSet(current, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行每次操作之前，判断当前锁持有者是否是当前对象，采用state计数，不用每次去释放锁。</p><p><strong>ReentrantLock中可重入锁实现</strong></p><p>这里看非公平锁的锁获取方法：</p><p>Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//就是这里</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在AQS中维护了一个private volatile int state来计数重入次数，避免了频繁的持有释放操作，这样既提升了效率，又避免了死锁。</p><h3 id="三、独享锁-共享锁"><a href="#三、独享锁-共享锁" class="headerlink" title="三、独享锁 / 共享锁"></a>三、独享锁 / 共享锁</h3><p>独享锁和共享锁在你去读C.U.T包下的ReeReentrantLock和ReentrantReadWriteLock你就会发现，它俩一个是独享一个是共享锁。</p><ul><li>独享锁：该锁每一次只能被一个线程所持有。</li><li>共享锁：该锁可被多个线程共有，典型的就是ReentrantReadWriteLock里的读锁，它的读锁是可以被共享的，但是它的写锁确每次只能被独占。</li></ul><p>另外读锁的共享可保证并发读是非常高效的，但是读写和写写，写读都是互斥的。</p><p>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。</p><p>对于Synchronized而言，当然是独享锁。</p><h3 id="四、互斥锁-读写锁"><a href="#四、互斥锁-读写锁" class="headerlink" title="四、互斥锁 / 读写锁"></a>四、互斥锁 / 读写锁</h3><h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p>在访问共享资源之前对进行加锁操作，在访问完成之后进行解锁操作。 加锁后，任何其他试图再次加锁的线程会被阻塞，直到当前进程解锁。</p><p>如果解锁时有一个以上的线程阻塞，那么所有该锁上的线程都被编程就绪状态， 第一个变为就绪状态的线程又执行加锁操作，那么其他的线程又会进入等待。 在这种方式下，只有一个线程能够访问被互斥锁保护的资源</p><h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><p>读写锁既是互斥锁，又是共享锁，read模式是共享，write是互斥(排它锁)的。</p><p>读写锁有三种状态：读加锁状态、写加锁状态和不加锁状态</p><p>读写锁在Java中的具体实现就是<code>ReadWriteLock</code></p><p>一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占有读模式的读写锁。</p><p>只有一个线程可以占有写状态的锁，但可以有多个线程同时占有读状态锁，这也是它可以实现高并发的原因。当其处于写状态锁下，任何想要尝试获得锁的线程都会被阻塞，直到写状态锁被释放；如果是处于读状态锁下，允许其它线程获得它的读状态锁，但是不允许获得它的写状态锁，直到所有线程的读状态锁被释放；为了避免想要尝试写操作的线程一直得不到写状态锁，当读写锁感知到有线程想要获得写状态锁时，便会阻塞其后所有想要获得读状态锁的线程。所以读写锁非常适合资源的读操作远多于写操作的情况。</p><h3 id="五、乐观锁-悲观锁"><a href="#五、乐观锁-悲观锁" class="headerlink" title="五、乐观锁 / 悲观锁"></a>五、乐观锁 / 悲观锁</h3><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。<code>Java</code>中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于<code>write_condition</code>机制，其实都是提供的乐观锁。在<code>Java</code>中<code>java.util.concurrent.atomic</code>包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。</p><h3 id="六、分段锁"><a href="#六、分段锁" class="headerlink" title="六、分段锁"></a>六、分段锁</h3><p>分段锁其实是一种锁的设计，并不是具体的一种锁，对于<code>ConcurrentHashMap</code>而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。</p><p>并发容器类的加锁机制是基于粒度更小的分段锁，分段锁也是提升多并发程序性能的重要手段之一。</p><p>在并发程序中，串行操作是会降低可伸缩性，并且上下文切换也会减低性能。在锁上发生竞争时将通水导致这两种问题，使用独占锁时保护受限资源的时候，基本上是采用串行方式—-每次只能有一个线程能访问它。所以对于可伸缩性来说最大的威胁就是独占锁。</p><p>我们一般有三种方式降低锁的竞争程度：</p><p>1、减少锁的持有时间</p><p>2、降低锁的请求频率</p><p>3、使用带有协调机制的独占锁，这些机制允许更高的并发性。</p><p>在某些情况下我们可以将锁分解技术进一步扩展为一组独立对象上的锁进行分解，这成为分段锁。</p><p>其实说的简单一点就是：</p><p>容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是<code>ConcurrentHashMap</code>所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p><p>比如：在ConcurrentHashMap中使用了一个包含16个锁的数组，每个锁保护所有散列桶的1/16，其中第N个散列桶由第（N mod 16）个锁来保护。假设使用合理的散列算法使关键字能够均匀的分部，那么这大约能使对锁的请求减少到越来的1/16。也正是这项技术使得ConcurrentHashMap支持多达16个并发的写入线程。</p><h3 id="七、偏向锁-轻量级锁-重量级锁"><a href="#七、偏向锁-轻量级锁-重量级锁" class="headerlink" title="七、偏向锁 / 轻量级锁 / 重量级锁"></a>七、偏向锁 / 轻量级锁 / 重量级锁</h3><p>锁的状态：</p><ul><li>无锁状态</li><li>偏向锁状态</li><li>轻量级锁状态</li><li>重量级锁状态</li></ul><p>锁的状态是通过对象监视器在对象头中的字段来表明的。</p><p>四种状态会随着竞争的情况逐渐升级，而且是不可逆的过程，即不可降级。</p><p>这四种状态都不是Java语言中的锁，而是Jvm为了提高锁的获取与释放效率而做的优化(使用synchronized时)。</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。</p><h4 id="轻量级"><a href="#轻量级" class="headerlink" title="轻量级"></a>轻量级</h4><p>轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。</p><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。</p><h3 id="八、自旋锁"><a href="#八、自旋锁" class="headerlink" title="八、自旋锁"></a>八、自旋锁</h3><p>我们知道CAS算法是乐观锁的一种实现方式，CAS算法中又涉及到自旋锁，所以这里给大家讲一下什么是自旋锁。</p><h4 id="简单回顾一下CAS算法"><a href="#简单回顾一下CAS算法" class="headerlink" title="简单回顾一下CAS算法"></a>简单回顾一下CAS算法</h4><p><code>CAS</code>是英文单词<code>Compare and Swap</code>（比较并交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（<code>Non-blocking Synchronization</code>）。CAS算法涉及到三个操作数</p><ul><li>需要读写的内存值 V</li><li>进行比较的值 A</li><li>拟写入的新值 B</li></ul><p>更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B，否则不会执行任何操作。一般情况下是一个自旋操作，即不断的重试。</p><h4 id="什么是自旋锁？"><a href="#什么是自旋锁？" class="headerlink" title="什么是自旋锁？"></a>什么是自旋锁？</h4><p>自旋锁（spinlock）：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。</p><p>它是为实现保护共享资源而提出一种锁机制。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，”自旋”一词就是因此而得名。</p><h4 id="Java如何实现自旋锁？"><a href="#Java如何实现自旋锁？" class="headerlink" title="Java如何实现自旋锁？"></a>Java如何实现自旋锁？</h4><p>下面是个简单的例子：</p><p>Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Thread&gt; cas = <span class="keyword">new</span> AtomicReference&lt;Thread&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="comment">// 利用CAS</span></span><br><span class="line">        <span class="keyword">while</span> (!cas.compareAndSet(<span class="keyword">null</span>, current)) &#123;</span><br><span class="line">            <span class="comment">// DO nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        cas.compareAndSet(current, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lock（)方法利用的CAS，当第一个线程A获取锁的时候，能够成功获取到，不会进入while循环，如果此时线程A没有释放锁，另一个线程B又来获取锁，此时由于不满足CAS，所以就会进入while循环，不断判断是否满足CAS，直到A线程调用unlock方法释放了该锁。</p><h4 id="自旋锁存在的问题"><a href="#自旋锁存在的问题" class="headerlink" title="自旋锁存在的问题"></a>自旋锁存在的问题</h4><p>1、如果某个线程持有锁的时间过长，就会导致其它等待获取锁的线程进入循环等待，消耗CPU。使用不当会造成CPU使用率极高。</p><p>2、上面Java实现的自旋锁不是公平的，即无法满足等待时间最长的线程优先获取锁。不公平的锁就会存在“线程饥饿”问题。</p><h4 id="自旋锁的优点"><a href="#自旋锁的优点" class="headerlink" title="自旋锁的优点"></a>自旋锁的优点</h4><p>1、自旋锁不会使线程状态发生切换，一直处于用户态，即线程一直都是active的；不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快</p><p>2、非自旋锁在获取不到锁的时候会进入阻塞状态，从而进入内核态，当获取到锁的时候需要从内核态恢复，需要线程上下文切换。 （线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能）</p><h4 id="可重入的自旋锁和不可重入的自旋锁"><a href="#可重入的自旋锁和不可重入的自旋锁" class="headerlink" title="可重入的自旋锁和不可重入的自旋锁"></a>可重入的自旋锁和不可重入的自旋锁</h4><p>文章开始的时候的那段代码，仔细分析一下就可以看出，它是不支持重入的，即当一个线程第一次已经获取到了该锁，在锁释放之前又一次重新获取该锁，第二次就不能成功获取到。由于不满足CAS，所以第二次获取会进入while循环等待，而如果是可重入锁，第二次也是应该能够成功获取到的。</p><p>而且，即使第二次能够成功获取，那么当第一次释放锁的时候，第二次获取到的锁也会被释放，而这是不合理的。</p><p>为了实现可重入锁，我们需要引入一个计数器，用来记录获取锁的线程数。</p><p>Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantSpinLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Thread&gt; cas = <span class="keyword">new</span> AtomicReference&lt;Thread&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span> (current == cas.get()) &#123; <span class="comment">// 如果当前线程已经获取到了锁，线程数增加一，然后返回</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没获取到锁，则通过CAS自旋</span></span><br><span class="line">        <span class="keyword">while</span> (!cas.compareAndSet(<span class="keyword">null</span>, current)) &#123;</span><br><span class="line">            <span class="comment">// DO nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread cur = Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span> (cur == cas.get()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;<span class="comment">// 如果大于0，表示当前线程多次获取了该锁，释放锁通过count减一来模拟</span></span><br><span class="line">                count--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果count==0，可以将锁释放，这样就能保证获取锁的次数与释放锁的次数是一致的了。</span></span><br><span class="line">                cas.compareAndSet(cur, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自旋锁与互斥锁"><a href="#自旋锁与互斥锁" class="headerlink" title="自旋锁与互斥锁"></a>自旋锁与互斥锁</h4><ul><li>自旋锁与互斥锁都是为了实现保护资源共享的机制。</li><li>无论是自旋锁还是互斥锁，在任意时刻，都最多只能有一个保持者。</li><li>获取互斥锁的线程，如果锁已经被占用，则该线程将进入睡眠状态；获取自旋锁的线程则不会睡眠，而是一直循环等待锁释放。</li></ul><h4 id="自旋锁总结"><a href="#自旋锁总结" class="headerlink" title="自旋锁总结"></a>自旋锁总结</h4><ul><li>自旋锁：线程获取锁的时候，如果锁被其他线程持有，则当前线程将循环等待，直到获取到锁。</li><li>自旋锁等待期间，线程的状态不会改变，线程一直是用户态并且是活动的(active)。</li><li>自旋锁如果持有锁的时间太长，则会导致其它等待获取锁的线程耗尽CPU。</li><li>自旋锁本身无法保证公平性，同时也无法保证可重入性。</li><li>基于自旋锁，可以实现具备公平性和可重入性质的锁。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java-中15种锁的介绍：公平锁，可重入锁，独享锁，互斥锁，乐观锁，分段锁，自旋锁等等&quot;&gt;&lt;a href=&quot;#Java-中15种锁的介绍：公平锁，可重入锁，独享锁，互斥锁，乐观锁，分段锁，自旋锁等等&quot; class=&quot;headerlink&quot; title=&quot;Java
      
    
    </summary>
    
    
    
      <category term="Java" scheme="https://tomones.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot日志链路追踪实现方案</title>
    <link href="https://tomones.github.io/2020/05/30/SpringBoot%E6%97%A5%E5%BF%97%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/"/>
    <id>https://tomones.github.io/2020/05/30/SpringBoot%E6%97%A5%E5%BF%97%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/</id>
    <published>2020-05-30T15:05:53.000Z</published>
    <updated>2020-05-30T15:07:41.230Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MDC"><a href="#MDC" class="headerlink" title="MDC"></a>MDC</h3><p>MDC ( Mapped Diagnostic Contexts )，它是一个线程安全的存放诊断日志的容器。</p><p>Logback设计的一个目标之一是对分布式应用系统的审计和调试。在现在的分布式系统中，需要同时处理很多的请求。如何来很好的区分日志到底是那个请求输出的呢？我们可以为每一个请求生一个logger，但是这样子最产生大量的资源浪费，并且随着请求的增多这种方式会将服务器资源消耗殆尽，所以这种方式并不推荐。</p><p>一种更加轻量级的实现是使用MDC机制，在处理请求前将请求的唯一标示放到MDC容器中如sessionId，这个唯一标示会随着日志一起输出，以此来区分该条日志是属于那个请求的。并在请求处理完成之后清除MDC容器。底层是采用ThreadLocal实现的。</p><h3 id="TraceID工具类"><a href="#TraceID工具类" class="headerlink" title="TraceID工具类"></a>TraceID工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceIdUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TRACE_ID = <span class="string">"traceId"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当traceId为空时，显示的traceId。随意。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_TRACE_ID = <span class="string">"0"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置traceId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setTraceId</span><span class="params">(String traceId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果参数为空，则设置默认traceId</span></span><br><span class="line">        traceId = StringUtils.isBlank(traceId) ? DEFAULT_TRACE_ID : traceId;</span><br><span class="line">        <span class="comment">//将traceId放到MDC中</span></span><br><span class="line">        MDC.put(TRACE_ID, traceId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取traceId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getTraceId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取</span></span><br><span class="line">        String traceId = MDC.get(TRACE_ID);</span><br><span class="line">        <span class="comment">//如果traceId为空，则返回默认值</span></span><br><span class="line">        <span class="keyword">return</span> StringUtils.isBlank(traceId) ? DEFAULT_TRACE_ID : traceId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断traceId为默认值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">defaultTraceId</span><span class="params">(String traceId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DEFAULT_TRACE_ID.equals(traceId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成traceId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">genTraceId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UUID.randomUUID().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="增加过滤器"><a href="#增加过滤器" class="headerlink" title="增加过滤器"></a>增加过滤器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter</span>(urlPatterns = <span class="string">"/*"</span>, filterName = <span class="string">"traceIdFilter"</span>)</span><br><span class="line"><span class="meta">@Order</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceIdFilter</span> <span class="keyword">extends</span> <span class="title">GenericFilterBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        initTraceId((HttpServletRequest) servletRequest);</span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * traceId初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initTraceId</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//尝试获取http请求中的traceId</span></span><br><span class="line">        String traceId = request.getParameter(<span class="string">"traceId"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果当前traceId为空或者为默认traceId，则生成新的traceId</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(traceId) || TraceIdUtil.defaultTraceId(traceId)) &#123;</span><br><span class="line">            traceId = TraceIdUtil.genTraceId();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置traceId</span></span><br><span class="line">        TraceIdUtil.setTraceId(traceId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="logback-spring-xml配置"><a href="#logback-spring-xml配置" class="headerlink" title="logback-spring.xml配置"></a>logback-spring.xml配置</h2><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;控制台格式 [%X&#123; traceId &#125;] - 为输出当前的TraceID 格式</span><br><span class="line">&lt;property name&#x3D;&quot;CONSOLE_LOG_PATTERN&quot; value&#x3D;&quot;$&#123;CONSOLE_LOG_PATTERN:-%clr( %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; [%X&#123; traceId &#125;] - %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;&#125;&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 日志级别从低到高分为TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，如果设置为WARN，则低于WARN的信息都不会输出 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- scan:当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- de<span class="doctag">bug:</span>当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>  <span class="attr">scan</span>=<span class="string">"true"</span> <span class="attr">scanPeriod</span>=<span class="string">"10 seconds"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--&lt;include resource="org/springframework/boot/logging/logback/base.xml" /&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">contextName</span>&gt;</span>logback<span class="tag">&lt;/<span class="name">contextName</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- name的值是变量的名称，value的值时变量定义的值。通过定义的值会被插入到logger上下文中。定义变量后，可以使“$&#123;&#125;”来使用变量。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"log.path"</span> <span class="attr">value</span>=<span class="string">"./logs"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 彩色日志 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 彩色日志依赖的渲染类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">conversionRule</span> <span class="attr">conversionWord</span>=<span class="string">"clr"</span> <span class="attr">converterClass</span>=<span class="string">"org.springframework.boot.logging.logback.ColorConverter"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">conversionRule</span> <span class="attr">conversionWord</span>=<span class="string">"wex"</span> <span class="attr">converterClass</span>=<span class="string">"org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">conversionRule</span> <span class="attr">conversionWord</span>=<span class="string">"wEx"</span> <span class="attr">converterClass</span>=<span class="string">"org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 彩色日志格式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"CONSOLE_LOG_PATTERN"</span> <span class="attr">value</span>=<span class="string">"$&#123;CONSOLE_LOG_PATTERN:-%clr( %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; [%X&#123; traceId &#125;] - %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;&#125;"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--输出到控制台--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"CONSOLE"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--此日志appender是为开发使用，只配置最底级别，控制台输出的日志级别是大于或等于此级别的日志信息--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.ThresholdFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>info<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Pattern</span>&gt;</span>$&#123;CONSOLE_LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">Pattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 设置字符集 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--输出到文件--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 时间滚动输出 level为 DEBUG 日志 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"DEBUG_FILE"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 正在记录的日志文件的路径及文件名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;log.path&#125;/log_debug.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--日志文件输出格式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span> <span class="comment">&lt;!-- 设置字符集 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志归档 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/debug/log-debug-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>100MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--日志文件保留天数--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>15<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 此日志文件只记录debug级别的 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>debug<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 时间滚动输出 level为 INFO 日志 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"INFO_FILE"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 正在记录的日志文件的路径及文件名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;log.path&#125;/log_info.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--日志文件输出格式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 每天日志归档路径以及格式 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/info/log-info-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>100MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--日志文件保留天数--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>15<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 此日志文件只记录info级别的 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>info<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 时间滚动输出 level为 WARN 日志 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"WARN_FILE"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 正在记录的日志文件的路径及文件名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;log.path&#125;/log_warn.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--日志文件输出格式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span> <span class="comment">&lt;!-- 此处设置字符集 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/warn/log-warn-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>100MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--日志文件保留天数--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>15<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 此日志文件只记录warn级别的 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>warn<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 时间滚动输出 level为 ERROR 日志 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"ERROR_FILE"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 正在记录的日志文件的路径及文件名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;log.path&#125;/log_error.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--日志文件输出格式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span> <span class="comment">&lt;!-- 此处设置字符集 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/error/log-error-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>100MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--日志文件保留天数--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>15<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 此日志文件只记录ERROR级别的 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        &lt;logger&gt;用来设置某一个包或者具体的某一个类的日志打印级别、</span></span><br><span class="line"><span class="comment">        以及指定&lt;appender&gt;。&lt;logger&gt;仅有一个name属性，</span></span><br><span class="line"><span class="comment">        一个可选的level和一个可选的addtivity属性。</span></span><br><span class="line"><span class="comment">        name:用来指定受此logger约束的某一个包或者具体的某一个类。</span></span><br><span class="line"><span class="comment">        level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，</span></span><br><span class="line"><span class="comment">              还有一个特俗值INHERITED或者同义词NULL，代表强制执行上级的级别。</span></span><br><span class="line"><span class="comment">              如果未设置此属性，那么当前logger将会继承上级的级别。</span></span><br><span class="line"><span class="comment">        addtivity:是否向上级logger传递打印信息。默认是true。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;logger name="org.springframework.web" level="info"/&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;logger name="org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor" level="INFO"/&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        使用mybatis的时候，sql语句是debug下才会打印，而这里我们只配置了info，所以想要查看sql语句的话，有以下两种操作：</span></span><br><span class="line"><span class="comment">        第一种把&lt;root level="info"&gt;改成&lt;root level="DEBUG"&gt;这样就会打印sql，不过这样日志那边会出现很多其他消息</span></span><br><span class="line"><span class="comment">        第二种就是单独给dao下目录配置debug模式，代码如下，这样配置sql语句会打印，其他还是正常info级别：</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        root节点是必选节点，用来指定最基础的日志输出级别，只有一个level属性</span></span><br><span class="line"><span class="comment">        level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，</span></span><br><span class="line"><span class="comment">        不能设置为INHERITED或者同义词NULL。默认是DEBUG</span></span><br><span class="line"><span class="comment">        可以包含零个或多个元素，标识这个appender将会添加到这个logger。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--开发环境:打印控制台--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;springProfile name="dev"&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 请更改此处包名！！！！！！或类 ！！！！！！--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;logger name="com.nmys.view" level="debug"/&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;/springProfile&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"info"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"CONSOLE"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"DEBUG_FILE"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"INFO_FILE"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"WARN_FILE"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"ERROR_FILE"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--生产环境:输出到文件--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;springProfile name="pro"&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;root level="info"&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;appender-ref ref="CONSOLE" /&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;appender-ref ref="DEBUG_FILE" /&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;appender-ref ref="INFO_FILE" /&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;appender-ref ref="ERROR_FILE" /&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;appender-ref ref="WARN_FILE" /&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;/root&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;/springProfile&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="多线程打印-TraceID"><a href="#多线程打印-TraceID" class="headerlink" title="多线程打印 TraceID"></a>多线程打印 TraceID</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LOGTestHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">"测试通过112321"</span>);</span><br><span class="line"></span><br><span class="line">        ThreadFactory namedThreadFactory = <span class="keyword">new</span> ThreadFactoryBuilder()</span><br><span class="line">                .setNameFormat(<span class="string">"demo-pool-%d"</span>).build();</span><br><span class="line">        ExecutorService singleThreadPool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">3</span>, <span class="number">5</span>,</span><br><span class="line">                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">20</span>), namedThreadFactory, <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">        String traceId = TraceIdUtil.getTraceId();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            singleThreadPool.execute(()-&gt; &#123;</span><br><span class="line">                TraceIdUtil.setTraceId(traceId);</span><br><span class="line">                log.info(<span class="string">"测试多线程"</span>);</span><br><span class="line">                System.out.println(<span class="string">"asasdadad:"</span>+traceId);</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        singleThreadPool.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最终日志效果"><a href="#最终日志效果" class="headerlink" title="最终日志效果"></a>最终日志效果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"> 2020-04-02 15:46:52.623  INFO 21276 --- [nio-9009-exec-1] o.a.c.c.C.[Tomcat].[localhost].[&#x2F;]       : [] - Initializing Spring FrameworkServlet &#39;dispatcherServlet&#39;</span><br><span class="line"> 2020-04-02 15:46:52.623  INFO 21276 --- [nio-9009-exec-1] o.s.web.servlet.DispatcherServlet        : [] - FrameworkServlet &#39;dispatcherServlet&#39;: initialization started</span><br><span class="line"> 2020-04-02 15:46:52.658  INFO 21276 --- [nio-9009-exec-1] o.s.web.servlet.DispatcherServlet        : [] - FrameworkServlet &#39;dispatcherServlet&#39;: initialization completed in 34 ms</span><br><span class="line"> 2020-04-02 15:46:52.693  INFO 21276 --- [nio-9009-exec-1] com.example.demo.TestIDSController       : [7a02efc5-0722-491c-92e2-1b713c54ebd9] - name: cccssa</span><br><span class="line">当前的tranceID是：7a02efc5-0722-491c-92e2-1b713c54ebd9</span><br><span class="line"> 2020-04-02 15:46:52.694  INFO 21276 --- [nio-9009-exec-1] com.example.demo.IDP2.LOGTestHandler     : [7a02efc5-0722-491c-92e2-1b713c54ebd9] - 测试通过112321</span><br><span class="line"> 2020-04-02 15:46:52.701  INFO 21276 --- [    demo-pool-0] com.example.demo.IDP2.LOGTestHandler     : [7a02efc5-0722-491c-92e2-1b713c54ebd9] - 测试多线程</span><br><span class="line">asasdadad:7a02efc5-0722-491c-92e2-1b713c54ebd9</span><br><span class="line"> 2020-04-02 15:46:52.702  INFO 21276 --- [    demo-pool-0] com.example.demo.IDP2.LOGTestHandler     : [7a02efc5-0722-491c-92e2-1b713c54ebd9] - 测试多线程</span><br><span class="line">asasdadad:7a02efc5-0722-491c-92e2-1b713c54ebd9</span><br><span class="line"> 2020-04-02 15:46:52.702  INFO 21276 --- [    demo-pool-0] com.example.demo.IDP2.LOGTestHandler     : [7a02efc5-0722-491c-92e2-1b713c54ebd9] - 测试多线程</span><br><span class="line"> 2020-04-02 15:46:52.702  INFO 21276 --- [    demo-pool-1] com.example.demo.IDP2.LOGTestHandler     : [7a02efc5-0722-491c-92e2-1b713c54ebd9] - 测试多线程</span><br><span class="line"> 2020-04-02 15:46:52.702  INFO 21276 --- [    demo-pool-2] com.example.demo.IDP2.LOGTestHandler     : [7a02efc5-0722-491c-92e2-1b713c54ebd9] - 测试多线程</span><br><span class="line">asasdadad:7a02efc5-0722-491c-92e2-1b713c54ebd9</span><br><span class="line">asasdadad:7a02efc5-0722-491c-92e2-1b713c54ebd9</span><br><span class="line"> 2020-04-02 15:46:52.703  INFO 21276 --- [    demo-pool-1] com.example.demo.IDP2.LOGTestHandler     : [7a02efc5-0722-491c-92e2-1b713c54ebd9] - 测试多线程</span><br><span class="line">asasdadad:7a02efc5-0722-491c-92e2-1b713c54ebd9</span><br><span class="line">asasdadad:7a02efc5-0722-491c-92e2-1b713c54ebd9</span><br><span class="line"> 2020-04-02 15:46:52.703  INFO 21276 --- [    demo-pool-2] com.example.demo.IDP2.LOGTestHandler     : [7a02efc5-0722-491c-92e2-1b713c54ebd9] - 测试多线程</span><br><span class="line">asasdadad:7a02efc5-0722-491c-92e2-1b713c54ebd9</span><br><span class="line"> 2020-04-02 15:46:52.703  INFO 21276 --- [    demo-pool-1] com.example.demo.IDP2.LOGTestHandler     : [7a02efc5-0722-491c-92e2-1b713c54ebd9] - 测试多线程</span><br><span class="line">asasdadad:7a02efc5-0722-491c-92e2-1b713c54ebd9</span><br><span class="line"> 2020-04-02 15:46:52.703  INFO 21276 --- [    demo-pool-2] com.example.demo.IDP2.LOGTestHandler     : [7a02efc5-0722-491c-92e2-1b713c54ebd9] - 测试多线程</span><br><span class="line">asasdadad:7a02efc5-0722-491c-92e2-1b713c54ebd9</span><br><span class="line"> 2020-04-02 15:46:52.703  INFO 21276 --- [    demo-pool-1] com.example.demo.IDP2.LOGTestHandler     : [7a02efc5-0722-491c-92e2-1b713c54ebd9] - 测试多线程</span><br><span class="line">asasdadad:7a02efc5-0722-491c-92e2-1b713c54ebd9</span><br><span class="line"> 2020-04-02 15:46:52.703  INFO 21276 --- [    demo-pool-2] com.example.demo.IDP2.LOGTestHandler     : [7a02efc5-0722-491c-92e2-1b713c54ebd9] - 测试多线程</span><br><span class="line"> 2020-04-02 15:46:52.703  INFO 21276 --- [    demo-pool-1] com.example.demo.IDP2.LOGTestHandler     : [7a02efc5-0722-491c-92e2-1b713c54ebd9] - 测试多线程</span><br><span class="line">asasdadad:7a02efc5-0722-491c-92e2-1b713c54ebd9</span><br><span class="line">asasdadad:7a02efc5-0722-491c-92e2-1b713c54ebd9</span><br><span class="line"> 2020-04-02 15:46:52.703  INFO 21276 --- [    demo-pool-2] com.example.demo.IDP2.LOGTestHandler     : [7a02efc5-0722-491c-92e2-1b713c54ebd9] - 测试多线程</span><br><span class="line"> 2020-04-02 15:46:52.703  INFO 21276 --- [    demo-pool-1] com.example.demo.IDP2.LOGTestHandler     : [7a02efc5-0722-491c-92e2-1b713c54ebd9] - 测试多线程</span><br><span class="line">asasdadad:7a02efc5-0722-491c-92e2-1b713c54ebd9</span><br><span class="line">asasdadad:7a02efc5-0722-491c-92e2-1b713c54ebd9</span><br><span class="line"> 2020-04-02 15:46:52.703  INFO 21276 --- [    demo-pool-2] com.example.demo.IDP2.LOGTestHandler     : [7a02efc5-0722-491c-92e2-1b713c54ebd9] - 测试多线程</span><br><span class="line"> 2020-04-02 15:46:52.703  INFO 21276 --- [    demo-pool-0] com.example.demo.IDP2.LOGTestHandler     : [7a02efc5-0722-491c-92e2-1b713c54ebd9] - 测试多线程</span><br><span class="line"> 2020-04-02 15:46:52.703  INFO 21276 --- [    demo-pool-1] com.example.demo.IDP2.LOGTestHandler     : [7a02efc5-0722-491c-92e2-1b713c54ebd9] - 测试多线程</span><br><span class="line">asasdadad:7a02efc5-0722-491c-92e2-1b713c54ebd9</span><br><span class="line">asasdadad:7a02efc5-0722-491c-92e2-1b713c54ebd9</span><br><span class="line">asasdadad:7a02efc5-0722-491c-92e2-1b713c54ebd9</span><br><span class="line"> 2020-04-02 15:46:52.706  INFO 21276 --- [    demo-pool-2] com.example.demo.IDP2.LOGTestHandler     : [7a02efc5-0722-491c-92e2-1b713c54ebd9] - 测试多线程</span><br><span class="line"> 2020-04-02 15:46:52.706  INFO 21276 --- [    demo-pool-1] com.example.demo.IDP2.LOGTestHandler     : [7a02efc5-0722-491c-92e2-1b713c54ebd9] - 测试多线程</span><br><span class="line">asasdadad:7a02efc5-0722-491c-92e2-1b713c54ebd9</span><br><span class="line">asasdadad:7a02efc5-0722-491c-92e2-1b713c54ebd9</span><br><span class="line"> 2020-04-02 15:46:52.706  INFO 21276 --- [    demo-pool-0] com.example.demo.IDP2.LOGTestHandler     : [7a02efc5-0722-491c-92e2-1b713c54ebd9] - 测试多线程</span><br><span class="line">asasdadad:7a02efc5-0722-491c-92e2-1b713c54ebd9</span><br><span class="line"> 2020-04-02 15:46:52.773  INFO 21276 --- [nio-9009-exec-3] com.example.demo.TestIDSController       : [e0bd73f6-1d33-4eda-909f-21ff94f4b763] - name: cccssa</span><br><span class="line">当前的tranceID是：e0bd73f6-1d33-4eda-909f-21ff94f4b763</span><br><span class="line"> 2020-04-02 15:46:52.774  INFO 21276 --- [nio-9009-exec-3] com.example.demo.IDP2.LOGTestHandler     : [e0bd73f6-1d33-4eda-909f-21ff94f4b763] - 测试通过112321</span><br><span class="line"> 2020-04-02 15:46:52.775  INFO 21276 --- [    demo-pool-0] com.example.demo.IDP2.LOGTestHandler     : [e0bd73f6-1d33-4eda-909f-21ff94f4b763] - 测试多线程</span><br><span class="line"> 2020-04-02 15:46:52.777  INFO 21276 --- [    demo-pool-2] com.example.demo.IDP2.LOGTestHandler     : [e0bd73f6-1d33-4eda-909f-21ff94f4b763] - 测试多线程</span><br><span class="line"> 2020-04-02 15:46:52.777  INFO 21276 --- [    demo-pool-1] com.example.demo.IDP2.LOGTestHandler     : [e0bd73f6-1d33-4eda-909f-21ff94f4b763] - 测试多线程</span><br><span class="line">asasdadad:e0bd73f6-1d33-4eda-909f-21ff94f4b763</span><br><span class="line">asasdadad:e0bd73f6-1d33-4eda-909f-21ff94f4b763</span><br><span class="line">asasdadad:e0bd73f6-1d33-4eda-909f-21ff94f4b763</span><br><span class="line"> 2020-04-02 15:46:52.777  INFO 21276 --- [    demo-pool-0] com.example.demo.IDP2.LOGTestHandler     : [e0bd73f6-1d33-4eda-909f-21ff94f4b763] - 测试多线程</span><br><span class="line"> 2020-04-02 15:46:52.777  INFO 21276 --- [    demo-pool-1] com.example.demo.IDP2.LOGTestHandler     : [e0bd73f6-1d33-4eda-909f-21ff94f4b763] - 测试多线程</span><br><span class="line"> 2020-04-02 15:46:52.777  INFO 21276 --- [    demo-pool-2] com.example.demo.IDP2.LOGTestHandler     : [e0bd73f6-1d33-4eda-909f-21ff94f4b763] - 测试多线程</span><br><span class="line">asasdadad:e0bd73f6-1d33-4eda-909f-21ff94f4b763</span><br><span class="line">asasdadad:e0bd73f6-1d33-4eda-909f-21ff94f4b763</span><br><span class="line"> 2020-04-02 15:46:52.777  INFO 21276 --- [    demo-pool-0] com.example.demo.IDP2.LOGTestHandler     : [e0bd73f6-1d33-4eda-909f-21ff94f4b763] - 测试多线程</span><br><span class="line"> 2020-04-02 15:46:52.777  INFO 21276 --- [    demo-pool-2] com.example.demo.IDP2.LOGTestHandler     : [e0bd73f6-1d33-4eda-909f-21ff94f4b763] - 测试多线程</span><br><span class="line">asasdadad:e0bd73f6-1d33-4eda-909f-21ff94f4b763</span><br><span class="line">asasdadad:e0bd73f6-1d33-4eda-909f-21ff94f4b763</span><br><span class="line"> 2020-04-02 15:46:52.777  INFO 21276 --- [    demo-pool-0] com.example.demo.IDP2.LOGTestHandler     : [e0bd73f6-1d33-4eda-909f-21ff94f4b763] - 测试多线程</span><br><span class="line"> 2020-04-02 15:46:52.777  INFO 21276 --- [    demo-pool-2] com.example.demo.IDP2.LOGTestHandler     : [e0bd73f6-1d33-4eda-909f-21ff94f4b763] - 测试多线程</span><br><span class="line">asasdadad:e0bd73f6-1d33-4eda-909f-21ff94f4b763</span><br><span class="line"> 2020-04-02 15:46:52.777  INFO 21276 --- [    demo-pool-0] com.example.demo.IDP2.LOGTestHandler     : [e0bd73f6-1d33-4eda-909f-21ff94f4b763] - 测试多线程</span><br><span class="line">asasdadad:e0bd73f6-1d33-4eda-909f-21ff94f4b763</span><br><span class="line"> 2020-04-02 15:46:52.778  INFO 21276 --- [    demo-pool-0] com.example.demo.IDP2.LOGTestHandler     : [e0bd73f6-1d33-4eda-909f-21ff94f4b763] - 测试多线程</span><br><span class="line">asasdadad:e0bd73f6-1d33-4eda-909f-21ff94f4b763</span><br><span class="line">asasdadad:e0bd73f6-1d33-4eda-909f-21ff94f4b763</span><br><span class="line"> 2020-04-02 15:46:52.778  INFO 21276 --- [    demo-pool-1] com.example.demo.IDP2.LOGTestHandler     : [e0bd73f6-1d33-4eda-909f-21ff94f4b763] - 测试多线程</span><br><span class="line"> 2020-04-02 15:46:52.778  INFO 21276 --- [    demo-pool-2] com.example.demo.IDP2.LOGTestHandler     : [e0bd73f6-1d33-4eda-909f-21ff94f4b763] - 测试多线程</span><br><span class="line">asasdadad:e0bd73f6-1d33-4eda-909f-21ff94f4b763</span><br><span class="line"> 2020-04-02 15:46:52.778  INFO 21276 --- [    demo-pool-0] com.example.demo.IDP2.LOGTestHandler     : [e0bd73f6-1d33-4eda-909f-21ff94f4b763] - 测试多线程</span><br><span class="line">asasdadad:e0bd73f6-1d33-4eda-909f-21ff94f4b763</span><br><span class="line"> 2020-04-02 15:46:52.780  INFO 21276 --- [    demo-pool-0] com.example.demo.IDP2.LOGTestHandler     : [e0bd73f6-1d33-4eda-909f-21ff94f4b763] - 测试多线程</span><br><span class="line">asasdadad:e0bd73f6-1d33-4eda-909f-21ff94f4b763</span><br><span class="line"> 2020-04-02 15:46:52.781  INFO 21276 --- [    demo-pool-0] com.example.demo.IDP2.LOGTestHandler     : [e0bd73f6-1d33-4eda-909f-21ff94f4b763] - 测试多线程</span><br><span class="line">asasdadad:e0bd73f6-1d33-4eda-909f-21ff94f4b763</span><br><span class="line"> 2020-04-02 15:46:52.781  INFO 21276 --- [    demo-pool-0] com.example.demo.IDP2.LOGTestHandler     : [e0bd73f6-1d33-4eda-909f-21ff94f4b763] - 测试多线程</span><br><span class="line">asasdadad:e0bd73f6-1d33-4eda-909f-21ff94f4b763</span><br><span class="line"> 2020-04-02 15:46:52.781  INFO 21276 --- [    demo-pool-0] com.example.demo.IDP2.LOGTestHandler     : [e0bd73f6-1d33-4eda-909f-21ff94f4b763] - 测试多线程</span><br><span class="line">asasdadad:e0bd73f6-1d33-4eda-909f-21ff94f4b763</span><br><span class="line"> 2020-04-02 15:46:52.781  INFO 21276 --- [    demo-pool-0] com.example.demo.IDP2.LOGTestHandler     : [e0bd73f6-1d33-4eda-909f-21ff94f4b763] - 测试多线程</span><br><span class="line">asasdadad:e0bd73f6-1d33-4eda-909f-21ff94f4b763</span><br><span class="line">asasdadad:e0bd73f6-1d33-4eda-909f-21ff94f4b763</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;MDC&quot;&gt;&lt;a href=&quot;#MDC&quot; class=&quot;headerlink&quot; title=&quot;MDC&quot;&gt;&lt;/a&gt;MDC&lt;/h3&gt;&lt;p&gt;MDC ( Mapped Diagnostic Contexts )，它是一个线程安全的存放诊断日志的容器。&lt;/p&gt;
&lt;p&gt;Logb
      
    
    </summary>
    
    
    
      <category term="SpringBoot" scheme="https://tomones.github.io/tags/SpringBoot/"/>
    
  </entry>
  
</feed>
